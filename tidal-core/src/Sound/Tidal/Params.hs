module Sound.Tidal.Params where

-- Please note, this file is generated by bin/generate-params.hs
-- Submit any pull requests against that file and/or params-header.hs
-- in the same folder, thanks.

{-
    Params.hs - Provides the basic control patterns available to TidalCycles by default
    Copyright (C) 2021, Alex McLean and contributors

    This library is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-}

import qualified Data.Map.Strict   as Map

import           Sound.Tidal.Types
import           Sound.Tidal.Value
-- import Sound.Tidal.Core ((#))
import           Data.Maybe        (fromMaybe)
import           Data.Word         (Word8)
import           Sound.Tidal.Utils

-- | group multiple params into one
grp :: Pattern p => [String -> ValueMap] -> p String -> p ValueMap
grp [] _ = silence
grp fs p = splitby <$> p
  where splitby name = Map.unions $ map (\(v, f) -> f v) $ zip (split name) fs
        split :: String -> [String]
        split = wordsBy (==':')

mF :: String -> String -> ValueMap
mF name v = fromMaybe Map.empty $ do f <- readMaybe v
                                     return $ Map.singleton name (VF f)

mI :: String -> String -> ValueMap
mI name v = fromMaybe Map.empty $ do i <- readMaybe v
                                     return $ Map.singleton name (VI i)

mS :: String -> String -> ValueMap
mS name v = Map.singleton name (VS v)

-- | Param makers

pF :: Pattern p => String -> p Double -> p ValueMap
pF name = fmap (Map.singleton name . VF)

pI :: Pattern p => String -> p Int -> p ValueMap
pI name = fmap (Map.singleton name . VI)

pB :: Pattern p => String -> p Bool -> p ValueMap
pB name = fmap (Map.singleton name . VB)

pR :: Pattern p => String -> p Time -> p ValueMap
pR name = fmap (Map.singleton name . VR)

pN :: Pattern p => String -> p Note -> p ValueMap
pN name = fmap (Map.singleton name . VN)

pS :: Pattern p => String -> p String -> p ValueMap
pS name = fmap (Map.singleton name . VS)

pX :: Pattern p => String -> p [Word8] -> p ValueMap
pX name = fmap (Map.singleton name . VX)

pStateF :: Pattern p => String -> String -> (Maybe Double -> Double) -> p ValueMap
pStateF name sName update = pure $ Map.singleton name $ VState statef
  where statef :: ValueMap -> (ValueMap, Value)
        statef sMap = (Map.insert sName v sMap, v)
          where v = VF $ update $ Map.lookup sName sMap >>= getF

pStateList :: Pattern p => String -> String -> [Value] -> p ValueMap
pStateList name sName xs = pure $ Map.singleton name $ VState statef
  where statef :: ValueMap -> (ValueMap, Value)
        statef sMap = (Map.insert sName (VList $ tail looped) sMap, head looped)
          where xs' = fromMaybe xs (Map.lookup sName sMap >>= getList)
                -- do this instead of a cycle, so it can get updated with the a list
                looped | null xs' = xs
                       | otherwise = xs'

pStateListF :: Pattern p => String -> String -> [Double] -> p ValueMap
pStateListF name sName = pStateList name sName . map VF

pStateListS :: Pattern p => String -> String -> [String] -> p ValueMap
pStateListS name sName = pStateList name sName . map VS

