{-# LANGUAGE FlexibleInstances #-}

-- (c) Alex McLean and contributors 2022
-- Shared under the terms of the GNU Public License v3.0

-- Please do not edit this file directly, it's generated from
-- bin/generate-composers.hs

module Sound.Tidal.Compose where

import           Data.Bits
import           Prelude                 hiding ((*>), (<*))

import qualified Data.Map.Strict         as Map

import           Sound.Tidal.Pattern
import           Sound.Tidal.Signal.Base
import           Sound.Tidal.Types

-- ************************************************************ --
-- Hack to allow 'union' to be used on any value

-- class for types that support a left-biased union
class Unionable a where
  union :: a -> a -> a

-- default union is just to take the left hand side..
instance Unionable a where
  union = const

instance {-# OVERLAPPING #-} Unionable ValueMap where
  union = Map.union

-- ************************************************************ --

opMix :: Applicative t => (a -> b -> c) -> t a -> t b -> t c
opMix f a b = f <$> a <*> b

opIn :: Pattern p => (a -> b -> c) -> p a -> p b -> p c
opIn f a b = f <$> a <* b

opOut :: Pattern p => (a -> b -> c) -> p a -> p b -> p c
opOut f a b = f <$> a *> b

opSqueeze :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueeze f pata patb = squeezeJoin $ fmap (\a -> fmap (f a)  patb) pata

opSqueezeOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueezeOut f pata patb = squeezeJoin $ fmap (\a -> fmap (`f` a)  pata) patb

opTrig :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrig f pata patb = trigJoin $ fmap (\a -> fmap (f a)  patb) pata

opTrigzero :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrigzero f pata patb = trigzeroJoin $ fmap (\a -> fmap (f a)  patb) pata

-- ************************************************************ --

-- Aliases

(#) :: (Pattern p, Unionable a) => p a -> p a -> p a
(#) = (|=)

struct :: (Pattern p, Unionable a) => p Bool -> p a -> p a
struct = flip keepifOut

structAll :: (Pattern p, Unionable a) => p a -> p a -> p a
structAll = flip keepOut

mask :: (Pattern p, Unionable a) => p Bool -> p a -> p a
mask = flip keepifIn

maskAll :: (Pattern p, Unionable a) => p a -> p a -> p a
maskAll = flip keepIn

reset :: (Unionable a) => Signal Bool -> Signal a -> Signal a
reset = flip keepifTrig

resetAll :: (Unionable a) => Signal a -> Signal a -> Signal a
resetAll = flip keepTrig

restart :: (Unionable a) => Signal Bool -> Signal a -> Signal a
restart = flip keepifTrigzero

restartAll :: (Unionable a) => Signal a -> Signal a -> Signal a
restartAll = flip keepTrigzero

-- ************************************************************ --

-- set

setMix, (|=|) :: (Pattern p, Unionable a) => p a -> p a -> p a
setMix pata patb = opMix (flip union) pata patb
(|=|) = setMix

setIn, (|=) :: (Pattern p, Unionable a) => p a -> p a -> p a
setIn pata patb = opIn (flip union) pata patb
(|=) = setIn

setOut, (=|) :: (Pattern p, Unionable a) => p a -> p a -> p a
setOut pata patb = opOut (flip union) pata patb
(=|) = setOut

setSqueeze, (||=) :: (Unionable a) => Signal a -> Signal a -> Signal a
setSqueeze pata patb = opSqueeze (flip union) pata patb
(||=) = setSqueeze

setSqueezeOut, (=||) :: (Unionable a) => Signal a -> Signal a -> Signal a
setSqueezeOut pata patb = opSqueezeOut (flip union) pata patb
(=||) = setSqueezeOut

setTrig, (!=) :: (Unionable a) => Signal a -> Signal a -> Signal a
setTrig pata patb = opTrig (flip union) pata patb
(!=) = setTrig

setTrigzero, (!!=) :: (Unionable a) => Signal a -> Signal a -> Signal a
setTrigzero pata patb = opTrigzero (flip union) pata patb
(!!=) = setTrigzero

infixl 4 |=|, |=, =|, ||=, =||, !=, !!=

-- keep

keepMix, (|.|) :: (Pattern p, Unionable a) => p a -> p a -> p a
keepMix pata patb = opMix union pata patb
(|.|) = keepMix

keepIn, (|.) :: (Pattern p, Unionable a) => p a -> p a -> p a
keepIn pata patb = opIn union pata patb
(|.) = keepIn

keepOut, (.|) :: (Pattern p, Unionable a) => p a -> p a -> p a
keepOut pata patb = opOut union pata patb
(.|) = keepOut

keepSqueeze, (||.) :: (Unionable a) => Signal a -> Signal a -> Signal a
keepSqueeze pata patb = opSqueeze union pata patb
(||.) = keepSqueeze

keepSqueezeOut, (.||) :: (Unionable a) => Signal a -> Signal a -> Signal a
keepSqueezeOut pata patb = opSqueezeOut union pata patb
(.||) = keepSqueezeOut

keepTrig, (!.) :: (Unionable a) => Signal a -> Signal a -> Signal a
keepTrig pata patb = opTrig union pata patb
(!.) = keepTrig

keepTrigzero, (!!.) :: (Unionable a) => Signal a -> Signal a -> Signal a
keepTrigzero pata patb = opTrigzero union pata patb
(!!.) = keepTrigzero

infixl 4 |.|, |., .|, ||., .||, !., !!.

-- keepif

keepifMix, (|?|) :: (Pattern p, Unionable a) => p a -> p Bool -> p a
keepifMix pata patb = filterJusts $ opMix (\a b -> if b then Just a else Nothing) pata patb
(|?|) = keepifMix

keepifIn, (|?) :: (Pattern p, Unionable a) => p a -> p Bool -> p a
keepifIn pata patb = filterJusts $ opIn (\a b -> if b then Just a else Nothing) pata patb
(|?) = keepifIn

keepifOut, (?|) :: (Pattern p, Unionable a) => p a -> p Bool -> p a
keepifOut pata patb = filterJusts $ opOut (\a b -> if b then Just a else Nothing) pata patb
(?|) = keepifOut

keepifSqueeze, (||?) :: (Unionable a) => Signal a -> Signal Bool -> Signal a
keepifSqueeze pata patb = filterJusts $ opSqueeze (\a b -> if b then Just a else Nothing) pata patb
(||?) = keepifSqueeze

keepifSqueezeOut, (?||) :: (Unionable a) => Signal a -> Signal Bool -> Signal a
keepifSqueezeOut pata patb = filterJusts $ opSqueezeOut (\a b -> if b then Just a else Nothing) pata patb
(?||) = keepifSqueezeOut

keepifTrig, (!?) :: (Unionable a) => Signal a -> Signal Bool -> Signal a
keepifTrig pata patb = filterJusts $ opTrig (\a b -> if b then Just a else Nothing) pata patb
(!?) = keepifTrig

keepifTrigzero, (!!?) :: (Unionable a) => Signal a -> Signal Bool -> Signal a
keepifTrigzero pata patb = filterJusts $ opTrigzero (\a b -> if b then Just a else Nothing) pata patb
(!!?) = keepifTrigzero

infixl 4 |?|, |?, ?|, ||?, ?||, !?, !!?

-- add

addMix, (|+|) :: (Pattern p, Num a) => p a -> p a -> p a
addMix pata patb = opMix (+) pata patb
(|+|) = addMix

addIn, (|+) :: (Pattern p, Num a) => p a -> p a -> p a
addIn pata patb = opIn (+) pata patb
(|+) = addIn

addOut, (+|) :: (Pattern p, Num a) => p a -> p a -> p a
addOut pata patb = opOut (+) pata patb
(+|) = addOut

addSqueeze, (||+) :: (Num a) => Signal a -> Signal a -> Signal a
addSqueeze pata patb = opSqueeze (+) pata patb
(||+) = addSqueeze

addSqueezeOut, (+||) :: (Num a) => Signal a -> Signal a -> Signal a
addSqueezeOut pata patb = opSqueezeOut (+) pata patb
(+||) = addSqueezeOut

addTrig, (!+) :: (Num a) => Signal a -> Signal a -> Signal a
addTrig pata patb = opTrig (+) pata patb
(!+) = addTrig

addTrigzero, (!!+) :: (Num a) => Signal a -> Signal a -> Signal a
addTrigzero pata patb = opTrigzero (+) pata patb
(!!+) = addTrigzero

infixl 4 |+|, |+, +|, ||+, +||, !+, !!+

-- sub

subMix, (|-|) :: (Pattern p, Num a) => p a -> p a -> p a
subMix pata patb = opMix (-) pata patb
(|-|) = subMix

subIn, (|-) :: (Pattern p, Num a) => p a -> p a -> p a
subIn pata patb = opIn (-) pata patb
(|-) = subIn

subOut, (-|) :: (Pattern p, Num a) => p a -> p a -> p a
subOut pata patb = opOut (-) pata patb
(-|) = subOut

subSqueeze, (||-) :: (Num a) => Signal a -> Signal a -> Signal a
subSqueeze pata patb = opSqueeze (-) pata patb
(||-) = subSqueeze

subSqueezeOut, (-||) :: (Num a) => Signal a -> Signal a -> Signal a
subSqueezeOut pata patb = opSqueezeOut (-) pata patb
(-||) = subSqueezeOut

subTrig, (!-) :: (Num a) => Signal a -> Signal a -> Signal a
subTrig pata patb = opTrig (-) pata patb
(!-) = subTrig

subTrigzero, (!!-) :: (Num a) => Signal a -> Signal a -> Signal a
subTrigzero pata patb = opTrigzero (-) pata patb
(!!-) = subTrigzero

infixl 4 |-|, |-, -|, ||-, -||, !-, !!-

-- mul

mulMix, (|*|) :: (Pattern p, Num a) => p a -> p a -> p a
mulMix pata patb = opMix (*) pata patb
(|*|) = mulMix

mulIn, (|*) :: (Pattern p, Num a) => p a -> p a -> p a
mulIn pata patb = opIn (*) pata patb
(|*) = mulIn

mulOut, (*|) :: (Pattern p, Num a) => p a -> p a -> p a
mulOut pata patb = opOut (*) pata patb
(*|) = mulOut

mulSqueeze, (||*) :: (Num a) => Signal a -> Signal a -> Signal a
mulSqueeze pata patb = opSqueeze (*) pata patb
(||*) = mulSqueeze

mulSqueezeOut, (*||) :: (Num a) => Signal a -> Signal a -> Signal a
mulSqueezeOut pata patb = opSqueezeOut (*) pata patb
(*||) = mulSqueezeOut

mulTrig, (!*) :: (Num a) => Signal a -> Signal a -> Signal a
mulTrig pata patb = opTrig (*) pata patb
(!*) = mulTrig

mulTrigzero, (!!*) :: (Num a) => Signal a -> Signal a -> Signal a
mulTrigzero pata patb = opTrigzero (*) pata patb
(!!*) = mulTrigzero

infixl 4 |*|, |*, *|, ||*, *||, !*, !!*

-- div

divMix, (|/|) :: (Pattern p, Fractional a) => p a -> p a -> p a
divMix pata patb = opMix (/) pata patb
(|/|) = divMix

divIn, (|/) :: (Pattern p, Fractional a) => p a -> p a -> p a
divIn pata patb = opIn (/) pata patb
(|/) = divIn

divOut, (/|) :: (Pattern p, Fractional a) => p a -> p a -> p a
divOut pata patb = opOut (/) pata patb
(/|) = divOut

divSqueeze, (||/) :: (Fractional a) => Signal a -> Signal a -> Signal a
divSqueeze pata patb = opSqueeze (/) pata patb
(||/) = divSqueeze

divSqueezeOut, (/||) :: (Fractional a) => Signal a -> Signal a -> Signal a
divSqueezeOut pata patb = opSqueezeOut (/) pata patb
(/||) = divSqueezeOut

divTrig, (!/) :: (Fractional a) => Signal a -> Signal a -> Signal a
divTrig pata patb = opTrig (/) pata patb
(!/) = divTrig

divTrigzero, (!!/) :: (Fractional a) => Signal a -> Signal a -> Signal a
divTrigzero pata patb = opTrigzero (/) pata patb
(!!/) = divTrigzero

infixl 4 |/|, |/, /|, ||/, /||, !/, !!/

-- mod

modMix, (|%|) :: (Pattern p, Integral a) => p a -> p a -> p a
modMix pata patb = opMix mod pata patb
(|%|) = modMix

modIn, (|%) :: (Pattern p, Integral a) => p a -> p a -> p a
modIn pata patb = opIn mod pata patb
(|%) = modIn

modOut, (%|) :: (Pattern p, Integral a) => p a -> p a -> p a
modOut pata patb = opOut mod pata patb
(%|) = modOut

modSqueeze, (||%) :: (Integral a) => Signal a -> Signal a -> Signal a
modSqueeze pata patb = opSqueeze mod pata patb
(||%) = modSqueeze

modSqueezeOut, (%||) :: (Integral a) => Signal a -> Signal a -> Signal a
modSqueezeOut pata patb = opSqueezeOut mod pata patb
(%||) = modSqueezeOut

modTrig, (!%) :: (Integral a) => Signal a -> Signal a -> Signal a
modTrig pata patb = opTrig mod pata patb
(!%) = modTrig

modTrigzero, (!!%) :: (Integral a) => Signal a -> Signal a -> Signal a
modTrigzero pata patb = opTrigzero mod pata patb
(!!%) = modTrigzero

infixl 4 |%|, |%, %|, ||%, %||, !%, !!%

-- pow

powMix, (|^|) :: (Pattern p, Integral a) => p a -> p a -> p a
powMix pata patb = opMix (^) pata patb
(|^|) = powMix

powIn, (|^) :: (Pattern p, Integral a) => p a -> p a -> p a
powIn pata patb = opIn (^) pata patb
(|^) = powIn

powOut, (^|) :: (Pattern p, Integral a) => p a -> p a -> p a
powOut pata patb = opOut (^) pata patb
(^|) = powOut

powSqueeze, (||^) :: (Integral a) => Signal a -> Signal a -> Signal a
powSqueeze pata patb = opSqueeze (^) pata patb
(||^) = powSqueeze

powSqueezeOut, (^||) :: (Integral a) => Signal a -> Signal a -> Signal a
powSqueezeOut pata patb = opSqueezeOut (^) pata patb
(^||) = powSqueezeOut

powTrig, (!^) :: (Integral a) => Signal a -> Signal a -> Signal a
powTrig pata patb = opTrig (^) pata patb
(!^) = powTrig

powTrigzero, (!!^) :: (Integral a) => Signal a -> Signal a -> Signal a
powTrigzero pata patb = opTrigzero (^) pata patb
(!!^) = powTrigzero

infixl 4 |^|, |^, ^|, ||^, ^||, !^, !!^

-- powf

powfMix, (|**|) :: (Pattern p, Floating a) => p a -> p a -> p a
powfMix pata patb = opMix (**) pata patb
(|**|) = powfMix

powfIn, (|**) :: (Pattern p, Floating a) => p a -> p a -> p a
powfIn pata patb = opIn (**) pata patb
(|**) = powfIn

powfOut, (**|) :: (Pattern p, Floating a) => p a -> p a -> p a
powfOut pata patb = opOut (**) pata patb
(**|) = powfOut

powfSqueeze, (||**) :: (Floating a) => Signal a -> Signal a -> Signal a
powfSqueeze pata patb = opSqueeze (**) pata patb
(||**) = powfSqueeze

powfSqueezeOut, (**||) :: (Floating a) => Signal a -> Signal a -> Signal a
powfSqueezeOut pata patb = opSqueezeOut (**) pata patb
(**||) = powfSqueezeOut

powfTrig, (!**) :: (Floating a) => Signal a -> Signal a -> Signal a
powfTrig pata patb = opTrig (**) pata patb
(!**) = powfTrig

powfTrigzero, (!!**) :: (Floating a) => Signal a -> Signal a -> Signal a
powfTrigzero pata patb = opTrigzero (**) pata patb
(!!**) = powfTrigzero

infixl 4 |**|, |**, **|, ||**, **||, !**, !!**

-- concat

concatMix, (|++|) :: Pattern p => p String -> p String -> p String
concatMix pata patb = opMix (++) pata patb
(|++|) = concatMix

concatIn, (|++) :: Pattern p => p String -> p String -> p String
concatIn pata patb = opIn (++) pata patb
(|++) = concatIn

concatOut, (++|) :: Pattern p => p String -> p String -> p String
concatOut pata patb = opOut (++) pata patb
(++|) = concatOut

concatSqueeze, (||++) :: Signal String -> Signal String -> Signal String
concatSqueeze pata patb = opSqueeze (++) pata patb
(||++) = concatSqueeze

concatSqueezeOut, (++||) :: Signal String -> Signal String -> Signal String
concatSqueezeOut pata patb = opSqueezeOut (++) pata patb
(++||) = concatSqueezeOut

concatTrig, (!++) :: Signal String -> Signal String -> Signal String
concatTrig pata patb = opTrig (++) pata patb
(!++) = concatTrig

concatTrigzero, (!!++) :: Signal String -> Signal String -> Signal String
concatTrigzero pata patb = opTrigzero (++) pata patb
(!!++) = concatTrigzero

infixl 4 |++|, |++, ++|, ||++, ++||, !++, !!++

-- band

bandMix, (|.&.|) :: (Pattern p, Bits a) => p a -> p a -> p a
bandMix pata patb = opMix (.&.) pata patb
(|.&.|) = bandMix

bandIn, (|.&.) :: (Pattern p, Bits a) => p a -> p a -> p a
bandIn pata patb = opIn (.&.) pata patb
(|.&.) = bandIn

bandOut, (.&.|) :: (Pattern p, Bits a) => p a -> p a -> p a
bandOut pata patb = opOut (.&.) pata patb
(.&.|) = bandOut

bandSqueeze, (||.&.) :: (Bits a) => Signal a -> Signal a -> Signal a
bandSqueeze pata patb = opSqueeze (.&.) pata patb
(||.&.) = bandSqueeze

bandSqueezeOut, (.&.||) :: (Bits a) => Signal a -> Signal a -> Signal a
bandSqueezeOut pata patb = opSqueezeOut (.&.) pata patb
(.&.||) = bandSqueezeOut

bandTrig, (!.&.) :: (Bits a) => Signal a -> Signal a -> Signal a
bandTrig pata patb = opTrig (.&.) pata patb
(!.&.) = bandTrig

bandTrigzero, (!!.&.) :: (Bits a) => Signal a -> Signal a -> Signal a
bandTrigzero pata patb = opTrigzero (.&.) pata patb
(!!.&.) = bandTrigzero

infixl 4 |.&.|, |.&., .&.|, ||.&., .&.||, !.&., !!.&.

-- bor

borMix, (|.|.|) :: (Pattern p, Bits a) => p a -> p a -> p a
borMix pata patb = opMix (.|.) pata patb
(|.|.|) = borMix

borIn, (|.|.) :: (Pattern p, Bits a) => p a -> p a -> p a
borIn pata patb = opIn (.|.) pata patb
(|.|.) = borIn

borOut, (.|.|) :: (Pattern p, Bits a) => p a -> p a -> p a
borOut pata patb = opOut (.|.) pata patb
(.|.|) = borOut

borSqueeze, (||.|.) :: (Bits a) => Signal a -> Signal a -> Signal a
borSqueeze pata patb = opSqueeze (.|.) pata patb
(||.|.) = borSqueeze

borSqueezeOut, (.|.||) :: (Bits a) => Signal a -> Signal a -> Signal a
borSqueezeOut pata patb = opSqueezeOut (.|.) pata patb
(.|.||) = borSqueezeOut

borTrig, (!.|.) :: (Bits a) => Signal a -> Signal a -> Signal a
borTrig pata patb = opTrig (.|.) pata patb
(!.|.) = borTrig

borTrigzero, (!!.|.) :: (Bits a) => Signal a -> Signal a -> Signal a
borTrigzero pata patb = opTrigzero (.|.) pata patb
(!!.|.) = borTrigzero

infixl 4 |.|.|, |.|., .|.|, ||.|., .|.||, !.|., !!.|.

-- bxor

bxorMix, (|.^.|) :: (Pattern p, Bits a) => p a -> p a -> p a
bxorMix pata patb = opMix xor pata patb
(|.^.|) = bxorMix

bxorIn, (|.^.) :: (Pattern p, Bits a) => p a -> p a -> p a
bxorIn pata patb = opIn xor pata patb
(|.^.) = bxorIn

bxorOut, (.^.|) :: (Pattern p, Bits a) => p a -> p a -> p a
bxorOut pata patb = opOut xor pata patb
(.^.|) = bxorOut

bxorSqueeze, (||.^.) :: (Bits a) => Signal a -> Signal a -> Signal a
bxorSqueeze pata patb = opSqueeze xor pata patb
(||.^.) = bxorSqueeze

bxorSqueezeOut, (.^.||) :: (Bits a) => Signal a -> Signal a -> Signal a
bxorSqueezeOut pata patb = opSqueezeOut xor pata patb
(.^.||) = bxorSqueezeOut

bxorTrig, (!.^.) :: (Bits a) => Signal a -> Signal a -> Signal a
bxorTrig pata patb = opTrig xor pata patb
(!.^.) = bxorTrig

bxorTrigzero, (!!.^.) :: (Bits a) => Signal a -> Signal a -> Signal a
bxorTrigzero pata patb = opTrigzero xor pata patb
(!!.^.) = bxorTrigzero

infixl 4 |.^.|, |.^., .^.|, ||.^., .^.||, !.^., !!.^.

-- bshiftl

bshiftlMix, (|.<<.|) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftlMix pata patb = opMix shiftL pata patb
(|.<<.|) = bshiftlMix

bshiftlIn, (|.<<.) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftlIn pata patb = opIn shiftL pata patb
(|.<<.) = bshiftlIn

bshiftlOut, (.<<.|) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftlOut pata patb = opOut shiftL pata patb
(.<<.|) = bshiftlOut

bshiftlSqueeze, (||.<<.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftlSqueeze pata patb = opSqueeze shiftL pata patb
(||.<<.) = bshiftlSqueeze

bshiftlSqueezeOut, (.<<.||) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftlSqueezeOut pata patb = opSqueezeOut shiftL pata patb
(.<<.||) = bshiftlSqueezeOut

bshiftlTrig, (!.<<.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftlTrig pata patb = opTrig shiftL pata patb
(!.<<.) = bshiftlTrig

bshiftlTrigzero, (!!.<<.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftlTrigzero pata patb = opTrigzero shiftL pata patb
(!!.<<.) = bshiftlTrigzero

infixl 4 |.<<.|, |.<<., .<<.|, ||.<<., .<<.||, !.<<., !!.<<.

-- bshiftr

bshiftrMix, (|.>>.|) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftrMix pata patb = opMix shiftR pata patb
(|.>>.|) = bshiftrMix

bshiftrIn, (|.>>.) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftrIn pata patb = opIn shiftR pata patb
(|.>>.) = bshiftrIn

bshiftrOut, (.>>.|) :: (Pattern p, Bits a) => p a -> p Int -> p a
bshiftrOut pata patb = opOut shiftR pata patb
(.>>.|) = bshiftrOut

bshiftrSqueeze, (||.>>.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftrSqueeze pata patb = opSqueeze shiftR pata patb
(||.>>.) = bshiftrSqueeze

bshiftrSqueezeOut, (.>>.||) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftrSqueezeOut pata patb = opSqueezeOut shiftR pata patb
(.>>.||) = bshiftrSqueezeOut

bshiftrTrig, (!.>>.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftrTrig pata patb = opTrig shiftR pata patb
(!.>>.) = bshiftrTrig

bshiftrTrigzero, (!!.>>.) :: (Bits a) => Signal a -> Signal Int -> Signal a
bshiftrTrigzero pata patb = opTrigzero shiftR pata patb
(!!.>>.) = bshiftrTrigzero

infixl 4 |.>>.|, |.>>., .>>.|, ||.>>., .>>.||, !.>>., !!.>>.

-- lt

ltMix, (|<|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
ltMix pata patb = opMix (<) pata patb
(|<|) = ltMix

ltIn, (|<) :: (Pattern p, Ord a) => p a -> p a -> p Bool
ltIn pata patb = opIn (<) pata patb
(|<) = ltIn

ltOut, (<|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
ltOut pata patb = opOut (<) pata patb
(<|) = ltOut

ltSqueeze, (||<) :: (Ord a) => Signal a -> Signal a -> Signal Bool
ltSqueeze pata patb = opSqueeze (<) pata patb
(||<) = ltSqueeze

ltSqueezeOut, (<||) :: (Ord a) => Signal a -> Signal a -> Signal Bool
ltSqueezeOut pata patb = opSqueezeOut (<) pata patb
(<||) = ltSqueezeOut

ltTrig, (!<) :: (Ord a) => Signal a -> Signal a -> Signal Bool
ltTrig pata patb = opTrig (<) pata patb
(!<) = ltTrig

ltTrigzero, (!!<) :: (Ord a) => Signal a -> Signal a -> Signal Bool
ltTrigzero pata patb = opTrigzero (<) pata patb
(!!<) = ltTrigzero

infixl 4 |<|, |<, <|, ||<, <||, !<, !!<

-- gt

gtMix, (|>|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gtMix pata patb = opMix (>) pata patb
(|>|) = gtMix

gtIn, (|>) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gtIn pata patb = opIn (>) pata patb
(|>) = gtIn

gtOut, (>|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gtOut pata patb = opOut (>) pata patb
(>|) = gtOut

gtSqueeze, (||>) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gtSqueeze pata patb = opSqueeze (>) pata patb
(||>) = gtSqueeze

gtSqueezeOut, (>||) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gtSqueezeOut pata patb = opSqueezeOut (>) pata patb
(>||) = gtSqueezeOut

gtTrig, (!>) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gtTrig pata patb = opTrig (>) pata patb
(!>) = gtTrig

gtTrigzero, (!!>) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gtTrigzero pata patb = opTrigzero (>) pata patb
(!!>) = gtTrigzero

infixl 4 |>|, |>, >|, ||>, >||, !>, !!>

-- lte

lteMix, (|<=|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
lteMix pata patb = opMix (<=) pata patb
(|<=|) = lteMix

lteIn, (|<=) :: (Pattern p, Ord a) => p a -> p a -> p Bool
lteIn pata patb = opIn (<=) pata patb
(|<=) = lteIn

lteOut, (<=|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
lteOut pata patb = opOut (<=) pata patb
(<=|) = lteOut

lteSqueeze, (||<=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
lteSqueeze pata patb = opSqueeze (<=) pata patb
(||<=) = lteSqueeze

lteSqueezeOut, (<=||) :: (Ord a) => Signal a -> Signal a -> Signal Bool
lteSqueezeOut pata patb = opSqueezeOut (<=) pata patb
(<=||) = lteSqueezeOut

lteTrig, (!<=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
lteTrig pata patb = opTrig (<=) pata patb
(!<=) = lteTrig

lteTrigzero, (!!<=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
lteTrigzero pata patb = opTrigzero (<=) pata patb
(!!<=) = lteTrigzero

infixl 4 |<=|, |<=, <=|, ||<=, <=||, !<=, !!<=

-- gte

gteMix, (|>=|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gteMix pata patb = opMix (>=) pata patb
(|>=|) = gteMix

gteIn, (|>=) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gteIn pata patb = opIn (>=) pata patb
(|>=) = gteIn

gteOut, (>=|) :: (Pattern p, Ord a) => p a -> p a -> p Bool
gteOut pata patb = opOut (>=) pata patb
(>=|) = gteOut

gteSqueeze, (||>=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gteSqueeze pata patb = opSqueeze (>=) pata patb
(||>=) = gteSqueeze

gteSqueezeOut, (>=||) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gteSqueezeOut pata patb = opSqueezeOut (>=) pata patb
(>=||) = gteSqueezeOut

gteTrig, (!>=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gteTrig pata patb = opTrig (>=) pata patb
(!>=) = gteTrig

gteTrigzero, (!!>=) :: (Ord a) => Signal a -> Signal a -> Signal Bool
gteTrigzero pata patb = opTrigzero (>=) pata patb
(!!>=) = gteTrigzero

infixl 4 |>=|, |>=, >=|, ||>=, >=||, !>=, !!>=

-- eq

eqMix, (|==|) :: (Pattern p, Eq a) => p a -> p a -> p Bool
eqMix pata patb = opMix (==) pata patb
(|==|) = eqMix

eqIn, (|==) :: (Pattern p, Eq a) => p a -> p a -> p Bool
eqIn pata patb = opIn (==) pata patb
(|==) = eqIn

eqOut, (==|) :: (Pattern p, Eq a) => p a -> p a -> p Bool
eqOut pata patb = opOut (==) pata patb
(==|) = eqOut

eqSqueeze, (||==) :: (Eq a) => Signal a -> Signal a -> Signal Bool
eqSqueeze pata patb = opSqueeze (==) pata patb
(||==) = eqSqueeze

eqSqueezeOut, (==||) :: (Eq a) => Signal a -> Signal a -> Signal Bool
eqSqueezeOut pata patb = opSqueezeOut (==) pata patb
(==||) = eqSqueezeOut

eqTrig, (!==) :: (Eq a) => Signal a -> Signal a -> Signal Bool
eqTrig pata patb = opTrig (==) pata patb
(!==) = eqTrig

eqTrigzero, (!!==) :: (Eq a) => Signal a -> Signal a -> Signal Bool
eqTrigzero pata patb = opTrigzero (==) pata patb
(!!==) = eqTrigzero

infixl 4 |==|, |==, ==|, ||==, ==||, !==, !!==

-- ne

neMix, (|/=|) :: (Pattern p, Eq a) => p a -> p a -> p Bool
neMix pata patb = opMix (/=) pata patb
(|/=|) = neMix

neIn, (|/=) :: (Pattern p, Eq a) => p a -> p a -> p Bool
neIn pata patb = opIn (/=) pata patb
(|/=) = neIn

neOut, (/=|) :: (Pattern p, Eq a) => p a -> p a -> p Bool
neOut pata patb = opOut (/=) pata patb
(/=|) = neOut

neSqueeze, (||/=) :: (Eq a) => Signal a -> Signal a -> Signal Bool
neSqueeze pata patb = opSqueeze (/=) pata patb
(||/=) = neSqueeze

neSqueezeOut, (/=||) :: (Eq a) => Signal a -> Signal a -> Signal Bool
neSqueezeOut pata patb = opSqueezeOut (/=) pata patb
(/=||) = neSqueezeOut

neTrig, (!/=) :: (Eq a) => Signal a -> Signal a -> Signal Bool
neTrig pata patb = opTrig (/=) pata patb
(!/=) = neTrig

neTrigzero, (!!/=) :: (Eq a) => Signal a -> Signal a -> Signal Bool
neTrigzero pata patb = opTrigzero (/=) pata patb
(!!/=) = neTrigzero

infixl 4 |/=|, |/=, /=|, ||/=, /=||, !/=, !!/=

-- and

andMix, (|&&|) :: Pattern p => p Bool -> p Bool -> p Bool
andMix pata patb = opMix (&&) pata patb
(|&&|) = andMix

andIn, (|&&) :: Pattern p => p Bool -> p Bool -> p Bool
andIn pata patb = opIn (&&) pata patb
(|&&) = andIn

andOut, (&&|) :: Pattern p => p Bool -> p Bool -> p Bool
andOut pata patb = opOut (&&) pata patb
(&&|) = andOut

andSqueeze, (||&&) :: Signal Bool -> Signal Bool -> Signal Bool
andSqueeze pata patb = opSqueeze (&&) pata patb
(||&&) = andSqueeze

andSqueezeOut, (&&||) :: Signal Bool -> Signal Bool -> Signal Bool
andSqueezeOut pata patb = opSqueezeOut (&&) pata patb
(&&||) = andSqueezeOut

andTrig, (!&&) :: Signal Bool -> Signal Bool -> Signal Bool
andTrig pata patb = opTrig (&&) pata patb
(!&&) = andTrig

andTrigzero, (!!&&) :: Signal Bool -> Signal Bool -> Signal Bool
andTrigzero pata patb = opTrigzero (&&) pata patb
(!!&&) = andTrigzero

infixl 4 |&&|, |&&, &&|, ||&&, &&||, !&&, !!&&

-- or

orMix, (|.||.|) :: Pattern p => p Bool -> p Bool -> p Bool
orMix pata patb = opMix (||) pata patb
(|.||.|) = orMix

orIn, (|.||.) :: Pattern p => p Bool -> p Bool -> p Bool
orIn pata patb = opIn (||) pata patb
(|.||.) = orIn

orOut, (.||.|) :: Pattern p => p Bool -> p Bool -> p Bool
orOut pata patb = opOut (||) pata patb
(.||.|) = orOut

orSqueeze, (||.||.) :: Signal Bool -> Signal Bool -> Signal Bool
orSqueeze pata patb = opSqueeze (||) pata patb
(||.||.) = orSqueeze

orSqueezeOut, (.||.||) :: Signal Bool -> Signal Bool -> Signal Bool
orSqueezeOut pata patb = opSqueezeOut (||) pata patb
(.||.||) = orSqueezeOut

orTrig, (!.||.) :: Signal Bool -> Signal Bool -> Signal Bool
orTrig pata patb = opTrig (||) pata patb
(!.||.) = orTrig

orTrigzero, (!!.||.) :: Signal Bool -> Signal Bool -> Signal Bool
orTrigzero pata patb = opTrigzero (||) pata patb
(!!.||.) = orTrigzero

infixl 4 |.||.|, |.||., .||.|, ||.||., .||.||, !.||., !!.||.


