module Sound.Tidal.Params where

-- Please note, this file is generated by bin/generate-params.hs
-- Submit any pull requests against that file and/or params-header.hs
-- in the same folder, thanks.

{-
    Params.hs - Provides the basic control patterns available to TidalCycles by default
    Copyright (C) 2021, Alex McLean and contributors

    This library is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-}

import qualified Data.Map.Strict     as Map

import           Sound.Tidal.Compose ((#))
import           Sound.Tidal.Pattern
import           Sound.Tidal.Types
import           Sound.Tidal.Value
-- import Sound.Tidal.Core ((#))
import           Data.Fixed          (mod')
import           Data.Maybe          (fromMaybe)
import           Data.Word           (Word8)
import           Sound.Tidal.Utils

-- | group multiple params into one
grp :: Pattern p => [String -> ValueMap] -> p String -> p ValueMap
grp [] _ = silence
grp fs p = splitby <$> p
  where splitby name = Map.unions $ map (\(v, f) -> f v) $ zip (split name) fs
        split :: String -> [String]
        split = wordsBy (==':')

mF :: String -> String -> ValueMap
mF name v = fromMaybe Map.empty $ do f <- readMaybe v
                                     return $ Map.singleton name (VF f)

mI :: String -> String -> ValueMap
mI name v = fromMaybe Map.empty $ do i <- readMaybe v
                                     return $ Map.singleton name (VI i)

mS :: String -> String -> ValueMap
mS name v = Map.singleton name (VS v)

-- | Param makers

pF :: Pattern p => String -> p Double -> p ValueMap
pF name = fmap (Map.singleton name . VF)

pI :: Pattern p => String -> p Int -> p ValueMap
pI name = fmap (Map.singleton name . VI)

pB :: Pattern p => String -> p Bool -> p ValueMap
pB name = fmap (Map.singleton name . VB)

pR :: Pattern p => String -> p Time -> p ValueMap
pR name = fmap (Map.singleton name . VR)

pN :: Pattern p => String -> p Note -> p ValueMap
pN name = fmap (Map.singleton name . VN)

pS :: Pattern p => String -> p String -> p ValueMap
pS name = fmap (Map.singleton name . VS)

pX :: Pattern p => String -> p [Word8] -> p ValueMap
pX name = fmap (Map.singleton name . VX)

pStateF :: Pattern p => String -> String -> (Maybe Double -> Double) -> p ValueMap
pStateF name sName update = pure $ Map.singleton name $ VState statef
  where statef :: ValueMap -> (ValueMap, Value)
        statef sMap = (Map.insert sName v sMap, v)
          where v = VF $ update $ Map.lookup sName sMap >>= getF

pStateList :: Pattern p => String -> String -> [Value] -> p ValueMap
pStateList name sName xs = pure $ Map.singleton name $ VState statef
  where statef :: ValueMap -> (ValueMap, Value)
        statef sMap = (Map.insert sName (VList $ tail looped) sMap, head looped)
          where xs' = fromMaybe xs (Map.lookup sName sMap >>= getList)
                -- do this instead of a cycle, so it can get updated with the a list
                looped | null xs' = xs
                       | otherwise = xs'

pStateListF :: Pattern p => String -> String -> [Double] -> p ValueMap
pStateListF name sName = pStateList name sName . map VF

pStateListS :: Pattern p => String -> String -> [String] -> p ValueMap
pStateListS name sName = pStateList name sName . map VS

-- | Grouped params

sound :: Pattern p => p String -> p ValueMap
sound = grp [mS "s", mF "n"]

sTake :: Pattern p =>  String -> [String] -> p ValueMap
sTake name xs = pStateListS "s" name xs

cc :: Pattern p =>  p String -> p ValueMap
cc = grp [mF "ccn", mF "ccv"]

nrpn :: Pattern p =>  p String -> p ValueMap
nrpn = grp [mI "nrpn", mI "val"]

nrpnn :: Pattern p =>  p Int -> p ValueMap
nrpnn = pI "nrpn"

nrpnv :: Pattern p =>  p Int -> p ValueMap
nrpnv = pI "val"

grain' :: Pattern p =>  p String -> p ValueMap
grain' = grp [mF "begin", mF "end"]

midinote :: Pattern p =>  p Note -> p ValueMap
midinote = note . (subtract 60 <$>)

drum :: Pattern p => p String -> p ValueMap
drum = n . (subtract 60 . drumN <$>)

drumN :: Num a => String -> a
drumN "hq" = 27
drumN "sl" = 28
drumN "ps" = 29
drumN "pl" = 30
drumN "st" = 31
drumN "sq" = 32
drumN "ml" = 33
drumN "mb" = 34
drumN "ab" = 35
drumN "bd" = 36
drumN "rm" = 37
drumN "sn" = 38
drumN "cp" = 39
drumN "es" = 40
drumN "lf" = 41
drumN "ch" = 42
drumN "lt" = 43
drumN "hh" = 44
drumN "ft" = 45
drumN "oh" = 46
drumN "mt" = 47
drumN "hm" = 48
drumN "cr" = 49
drumN "ht" = 50
drumN "ri" = 51
drumN "cy" = 52
drumN "be" = 53
drumN "ta" = 54
drumN "sc" = 55
drumN "cb" = 56
drumN "cs" = 57
drumN "vi" = 58
drumN "rc" = 59
drumN "hb" = 60
drumN "lb" = 61
drumN "mh" = 62
drumN "hc" = 63
drumN "lc" = 64
drumN "he" = 65
drumN "le" = 66
drumN "ag" = 67
drumN "la" = 68
drumN "ca" = 69
drumN "ma" = 70
drumN "sw" = 71
drumN "lw" = 72
drumN "sg" = 73
drumN "lg" = 74
drumN "cl" = 75
drumN "hi" = 76
drumN "li" = 77
drumN "mc" = 78
drumN "oc" = 79
drumN "tr" = 80
drumN "ot" = 81
drumN "sh" = 82
drumN "jb" = 83
drumN "bt" = 84
drumN "ct" = 85
drumN "ms" = 86
drumN "os" = 87
drumN _    = 0

-- Generated params

-- | a pattern of numbers that speed up (or slow down) samples while they play.
accelerate :: Pattern p => p Double -> p ValueMap
accelerate = pF "accelerate"
accelerateTake :: Pattern p => String -> [Double] -> p ValueMap
accelerateTake name xs = pStateListF "accelerate" name xs
accelerateCount :: Pattern p => String -> p ValueMap
accelerateCount name = pStateF "accelerate" name (maybe 0 (+1))
accelerateCountTo :: Pattern p => String -> p Double -> p ValueMap
accelerateCountTo name ipat = innerJoin $ (\i -> pStateF "accelerate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

acceleratebus :: Pattern p => p Int -> p Double -> p ValueMap
acceleratebus _ _ = error "Control parameter 'accelerate' can't be sent to a bus."

-- | like @gain@, but linear.
amp :: Pattern p => p Double -> p ValueMap
amp = pF "amp"
ampTake :: Pattern p => String -> [Double] -> p ValueMap
ampTake name xs = pStateListF "amp" name xs
ampCount :: Pattern p => String -> p ValueMap
ampCount name = pStateF "amp" name (maybe 0 (+1))
ampCountTo :: Pattern p => String -> p Double -> p ValueMap
ampCountTo name ipat = innerJoin $ (\i -> pStateF "amp" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ampbus :: Pattern p => p Int -> p Double -> p ValueMap
ampbus busid pat = pF "amp" pat # pI "^amp" busid
amprecv :: Pattern p => p Int -> p ValueMap
amprecv busid = pI "^amp" busid

-- |
array :: Pattern p => p [Word8] -> p ValueMap
array = pX "array"
arrayTake :: Pattern p => String -> [Double] -> p ValueMap
arrayTake name xs = pStateListF "array" name xs
arraybus :: Pattern p => p Int -> p [Word8] -> p ValueMap
arraybus _ _ = error "Control parameter 'array' can't be sent to a bus."

-- | a pattern of numbers to specify the attack time (in seconds) of an envelope applied to each sample.
attack :: Pattern p => p Double -> p ValueMap
attack = pF "attack"
attackTake :: Pattern p => String -> [Double] -> p ValueMap
attackTake name xs = pStateListF "attack" name xs
attackCount :: Pattern p => String -> p ValueMap
attackCount name = pStateF "attack" name (maybe 0 (+1))
attackCountTo :: Pattern p => String -> p Double -> p ValueMap
attackCountTo name ipat = innerJoin $ (\i -> pStateF "attack" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

attackbus :: Pattern p => p Int -> p Double -> p ValueMap
attackbus busid pat = pF "attack" pat # pI "^attack" busid
attackrecv :: Pattern p => p Int -> p ValueMap
attackrecv busid = pI "^attack" busid

-- | a pattern of numbers from 0 to 1. Sets the center frequency of the band-pass filter.
bandf :: Pattern p => p Double -> p ValueMap
bandf = pF "bandf"
bandfTake :: Pattern p => String -> [Double] -> p ValueMap
bandfTake name xs = pStateListF "bandf" name xs
bandfCount :: Pattern p => String -> p ValueMap
bandfCount name = pStateF "bandf" name (maybe 0 (+1))
bandfCountTo :: Pattern p => String -> p Double -> p ValueMap
bandfCountTo name ipat = innerJoin $ (\i -> pStateF "bandf" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

bandfbus :: Pattern p => p Int -> p Double -> p ValueMap
bandfbus busid pat = pF "bandf" pat # pI "^bandf" busid
bandfrecv :: Pattern p => p Int -> p ValueMap
bandfrecv busid = pI "^bandf" busid

-- | a pattern of anumbers from 0 to 1. Sets the q-factor of the band-pass filter.
bandq :: Pattern p => p Double -> p ValueMap
bandq = pF "bandq"
bandqTake :: Pattern p => String -> [Double] -> p ValueMap
bandqTake name xs = pStateListF "bandq" name xs
bandqCount :: Pattern p => String -> p ValueMap
bandqCount name = pStateF "bandq" name (maybe 0 (+1))
bandqCountTo :: Pattern p => String -> p Double -> p ValueMap
bandqCountTo name ipat = innerJoin $ (\i -> pStateF "bandq" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

bandqbus :: Pattern p => p Int -> p Double -> p ValueMap
bandqbus busid pat = pF "bandq" pat # pI "^bandq" busid
bandqrecv :: Pattern p => p Int -> p ValueMap
bandqrecv busid = pI "^bandq" busid

-- | a pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. `0.25` to cut off the first quarter from each sample.
begin :: Pattern p => p Double -> p ValueMap
begin = pF "begin"
beginTake :: Pattern p => String -> [Double] -> p ValueMap
beginTake name xs = pStateListF "begin" name xs
beginCount :: Pattern p => String -> p ValueMap
beginCount name = pStateF "begin" name (maybe 0 (+1))
beginCountTo :: Pattern p => String -> p Double -> p ValueMap
beginCountTo name ipat = innerJoin $ (\i -> pStateF "begin" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

beginbus :: Pattern p => p Int -> p Double -> p ValueMap
beginbus _ _ = error "Control parameter 'begin' can't be sent to a bus."

-- | Spectral binshift
binshift :: Pattern p => p Double -> p ValueMap
binshift = pF "binshift"
binshiftTake :: Pattern p => String -> [Double] -> p ValueMap
binshiftTake name xs = pStateListF "binshift" name xs
binshiftCount :: Pattern p => String -> p ValueMap
binshiftCount name = pStateF "binshift" name (maybe 0 (+1))
binshiftCountTo :: Pattern p => String -> p Double -> p ValueMap
binshiftCountTo name ipat = innerJoin $ (\i -> pStateF "binshift" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

binshiftbus :: Pattern p => p Int -> p Double -> p ValueMap
binshiftbus busid pat = pF "binshift" pat # pI "^binshift" busid
binshiftrecv :: Pattern p => p Int -> p ValueMap
binshiftrecv busid = pI "^binshift" busid

-- |
button0 :: Pattern p => p Double -> p ValueMap
button0 = pF "button0"
button0Take :: Pattern p => String -> [Double] -> p ValueMap
button0Take name xs = pStateListF "button0" name xs
button0Count :: Pattern p => String -> p ValueMap
button0Count name = pStateF "button0" name (maybe 0 (+1))
button0CountTo :: Pattern p => String -> p Double -> p ValueMap
button0CountTo name ipat = innerJoin $ (\i -> pStateF "button0" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button0bus :: Pattern p => p Int -> p Double -> p ValueMap
button0bus busid pat = pF "button0" pat # pI "^button0" busid
button0recv :: Pattern p => p Int -> p ValueMap
button0recv busid = pI "^button0" busid

-- |
button1 :: Pattern p => p Double -> p ValueMap
button1 = pF "button1"
button1Take :: Pattern p => String -> [Double] -> p ValueMap
button1Take name xs = pStateListF "button1" name xs
button1Count :: Pattern p => String -> p ValueMap
button1Count name = pStateF "button1" name (maybe 0 (+1))
button1CountTo :: Pattern p => String -> p Double -> p ValueMap
button1CountTo name ipat = innerJoin $ (\i -> pStateF "button1" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button1bus :: Pattern p => p Int -> p Double -> p ValueMap
button1bus busid pat = pF "button1" pat # pI "^button1" busid
button1recv :: Pattern p => p Int -> p ValueMap
button1recv busid = pI "^button1" busid

-- |
button10 :: Pattern p => p Double -> p ValueMap
button10 = pF "button10"
button10Take :: Pattern p => String -> [Double] -> p ValueMap
button10Take name xs = pStateListF "button10" name xs
button10Count :: Pattern p => String -> p ValueMap
button10Count name = pStateF "button10" name (maybe 0 (+1))
button10CountTo :: Pattern p => String -> p Double -> p ValueMap
button10CountTo name ipat = innerJoin $ (\i -> pStateF "button10" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button10bus :: Pattern p => p Int -> p Double -> p ValueMap
button10bus busid pat = pF "button10" pat # pI "^button10" busid
button10recv :: Pattern p => p Int -> p ValueMap
button10recv busid = pI "^button10" busid

-- |
button11 :: Pattern p => p Double -> p ValueMap
button11 = pF "button11"
button11Take :: Pattern p => String -> [Double] -> p ValueMap
button11Take name xs = pStateListF "button11" name xs
button11Count :: Pattern p => String -> p ValueMap
button11Count name = pStateF "button11" name (maybe 0 (+1))
button11CountTo :: Pattern p => String -> p Double -> p ValueMap
button11CountTo name ipat = innerJoin $ (\i -> pStateF "button11" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button11bus :: Pattern p => p Int -> p Double -> p ValueMap
button11bus busid pat = pF "button11" pat # pI "^button11" busid
button11recv :: Pattern p => p Int -> p ValueMap
button11recv busid = pI "^button11" busid

-- |
button12 :: Pattern p => p Double -> p ValueMap
button12 = pF "button12"
button12Take :: Pattern p => String -> [Double] -> p ValueMap
button12Take name xs = pStateListF "button12" name xs
button12Count :: Pattern p => String -> p ValueMap
button12Count name = pStateF "button12" name (maybe 0 (+1))
button12CountTo :: Pattern p => String -> p Double -> p ValueMap
button12CountTo name ipat = innerJoin $ (\i -> pStateF "button12" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button12bus :: Pattern p => p Int -> p Double -> p ValueMap
button12bus busid pat = pF "button12" pat # pI "^button12" busid
button12recv :: Pattern p => p Int -> p ValueMap
button12recv busid = pI "^button12" busid

-- |
button13 :: Pattern p => p Double -> p ValueMap
button13 = pF "button13"
button13Take :: Pattern p => String -> [Double] -> p ValueMap
button13Take name xs = pStateListF "button13" name xs
button13Count :: Pattern p => String -> p ValueMap
button13Count name = pStateF "button13" name (maybe 0 (+1))
button13CountTo :: Pattern p => String -> p Double -> p ValueMap
button13CountTo name ipat = innerJoin $ (\i -> pStateF "button13" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button13bus :: Pattern p => p Int -> p Double -> p ValueMap
button13bus busid pat = pF "button13" pat # pI "^button13" busid
button13recv :: Pattern p => p Int -> p ValueMap
button13recv busid = pI "^button13" busid

-- |
button14 :: Pattern p => p Double -> p ValueMap
button14 = pF "button14"
button14Take :: Pattern p => String -> [Double] -> p ValueMap
button14Take name xs = pStateListF "button14" name xs
button14Count :: Pattern p => String -> p ValueMap
button14Count name = pStateF "button14" name (maybe 0 (+1))
button14CountTo :: Pattern p => String -> p Double -> p ValueMap
button14CountTo name ipat = innerJoin $ (\i -> pStateF "button14" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button14bus :: Pattern p => p Int -> p Double -> p ValueMap
button14bus busid pat = pF "button14" pat # pI "^button14" busid
button14recv :: Pattern p => p Int -> p ValueMap
button14recv busid = pI "^button14" busid

-- |
button15 :: Pattern p => p Double -> p ValueMap
button15 = pF "button15"
button15Take :: Pattern p => String -> [Double] -> p ValueMap
button15Take name xs = pStateListF "button15" name xs
button15Count :: Pattern p => String -> p ValueMap
button15Count name = pStateF "button15" name (maybe 0 (+1))
button15CountTo :: Pattern p => String -> p Double -> p ValueMap
button15CountTo name ipat = innerJoin $ (\i -> pStateF "button15" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button15bus :: Pattern p => p Int -> p Double -> p ValueMap
button15bus busid pat = pF "button15" pat # pI "^button15" busid
button15recv :: Pattern p => p Int -> p ValueMap
button15recv busid = pI "^button15" busid

-- |
button2 :: Pattern p => p Double -> p ValueMap
button2 = pF "button2"
button2Take :: Pattern p => String -> [Double] -> p ValueMap
button2Take name xs = pStateListF "button2" name xs
button2Count :: Pattern p => String -> p ValueMap
button2Count name = pStateF "button2" name (maybe 0 (+1))
button2CountTo :: Pattern p => String -> p Double -> p ValueMap
button2CountTo name ipat = innerJoin $ (\i -> pStateF "button2" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button2bus :: Pattern p => p Int -> p Double -> p ValueMap
button2bus busid pat = pF "button2" pat # pI "^button2" busid
button2recv :: Pattern p => p Int -> p ValueMap
button2recv busid = pI "^button2" busid

-- |
button3 :: Pattern p => p Double -> p ValueMap
button3 = pF "button3"
button3Take :: Pattern p => String -> [Double] -> p ValueMap
button3Take name xs = pStateListF "button3" name xs
button3Count :: Pattern p => String -> p ValueMap
button3Count name = pStateF "button3" name (maybe 0 (+1))
button3CountTo :: Pattern p => String -> p Double -> p ValueMap
button3CountTo name ipat = innerJoin $ (\i -> pStateF "button3" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button3bus :: Pattern p => p Int -> p Double -> p ValueMap
button3bus busid pat = pF "button3" pat # pI "^button3" busid
button3recv :: Pattern p => p Int -> p ValueMap
button3recv busid = pI "^button3" busid

-- |
button4 :: Pattern p => p Double -> p ValueMap
button4 = pF "button4"
button4Take :: Pattern p => String -> [Double] -> p ValueMap
button4Take name xs = pStateListF "button4" name xs
button4Count :: Pattern p => String -> p ValueMap
button4Count name = pStateF "button4" name (maybe 0 (+1))
button4CountTo :: Pattern p => String -> p Double -> p ValueMap
button4CountTo name ipat = innerJoin $ (\i -> pStateF "button4" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button4bus :: Pattern p => p Int -> p Double -> p ValueMap
button4bus busid pat = pF "button4" pat # pI "^button4" busid
button4recv :: Pattern p => p Int -> p ValueMap
button4recv busid = pI "^button4" busid

-- |
button5 :: Pattern p => p Double -> p ValueMap
button5 = pF "button5"
button5Take :: Pattern p => String -> [Double] -> p ValueMap
button5Take name xs = pStateListF "button5" name xs
button5Count :: Pattern p => String -> p ValueMap
button5Count name = pStateF "button5" name (maybe 0 (+1))
button5CountTo :: Pattern p => String -> p Double -> p ValueMap
button5CountTo name ipat = innerJoin $ (\i -> pStateF "button5" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button5bus :: Pattern p => p Int -> p Double -> p ValueMap
button5bus busid pat = pF "button5" pat # pI "^button5" busid
button5recv :: Pattern p => p Int -> p ValueMap
button5recv busid = pI "^button5" busid

-- |
button6 :: Pattern p => p Double -> p ValueMap
button6 = pF "button6"
button6Take :: Pattern p => String -> [Double] -> p ValueMap
button6Take name xs = pStateListF "button6" name xs
button6Count :: Pattern p => String -> p ValueMap
button6Count name = pStateF "button6" name (maybe 0 (+1))
button6CountTo :: Pattern p => String -> p Double -> p ValueMap
button6CountTo name ipat = innerJoin $ (\i -> pStateF "button6" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button6bus :: Pattern p => p Int -> p Double -> p ValueMap
button6bus busid pat = pF "button6" pat # pI "^button6" busid
button6recv :: Pattern p => p Int -> p ValueMap
button6recv busid = pI "^button6" busid

-- |
button7 :: Pattern p => p Double -> p ValueMap
button7 = pF "button7"
button7Take :: Pattern p => String -> [Double] -> p ValueMap
button7Take name xs = pStateListF "button7" name xs
button7Count :: Pattern p => String -> p ValueMap
button7Count name = pStateF "button7" name (maybe 0 (+1))
button7CountTo :: Pattern p => String -> p Double -> p ValueMap
button7CountTo name ipat = innerJoin $ (\i -> pStateF "button7" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button7bus :: Pattern p => p Int -> p Double -> p ValueMap
button7bus busid pat = pF "button7" pat # pI "^button7" busid
button7recv :: Pattern p => p Int -> p ValueMap
button7recv busid = pI "^button7" busid

-- |
button8 :: Pattern p => p Double -> p ValueMap
button8 = pF "button8"
button8Take :: Pattern p => String -> [Double] -> p ValueMap
button8Take name xs = pStateListF "button8" name xs
button8Count :: Pattern p => String -> p ValueMap
button8Count name = pStateF "button8" name (maybe 0 (+1))
button8CountTo :: Pattern p => String -> p Double -> p ValueMap
button8CountTo name ipat = innerJoin $ (\i -> pStateF "button8" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button8bus :: Pattern p => p Int -> p Double -> p ValueMap
button8bus busid pat = pF "button8" pat # pI "^button8" busid
button8recv :: Pattern p => p Int -> p ValueMap
button8recv busid = pI "^button8" busid

-- |
button9 :: Pattern p => p Double -> p ValueMap
button9 = pF "button9"
button9Take :: Pattern p => String -> [Double] -> p ValueMap
button9Take name xs = pStateListF "button9" name xs
button9Count :: Pattern p => String -> p ValueMap
button9Count name = pStateF "button9" name (maybe 0 (+1))
button9CountTo :: Pattern p => String -> p Double -> p ValueMap
button9CountTo name ipat = innerJoin $ (\i -> pStateF "button9" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

button9bus :: Pattern p => p Int -> p Double -> p ValueMap
button9bus busid pat = pF "button9" pat # pI "^button9" busid
button9recv :: Pattern p => p Int -> p ValueMap
button9recv busid = pI "^button9" busid

-- |
ccn :: Pattern p => p Double -> p ValueMap
ccn = pF "ccn"
ccnTake :: Pattern p => String -> [Double] -> p ValueMap
ccnTake name xs = pStateListF "ccn" name xs
ccnCount :: Pattern p => String -> p ValueMap
ccnCount name = pStateF "ccn" name (maybe 0 (+1))
ccnCountTo :: Pattern p => String -> p Double -> p ValueMap
ccnCountTo name ipat = innerJoin $ (\i -> pStateF "ccn" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ccnbus :: Pattern p => p Int -> p Double -> p ValueMap
ccnbus _ _ = error "Control parameter 'ccn' can't be sent to a bus."

-- |
ccv :: Pattern p => p Double -> p ValueMap
ccv = pF "ccv"
ccvTake :: Pattern p => String -> [Double] -> p ValueMap
ccvTake name xs = pStateListF "ccv" name xs
ccvCount :: Pattern p => String -> p ValueMap
ccvCount name = pStateF "ccv" name (maybe 0 (+1))
ccvCountTo :: Pattern p => String -> p Double -> p ValueMap
ccvCountTo name ipat = innerJoin $ (\i -> pStateF "ccv" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ccvbus :: Pattern p => p Int -> p Double -> p ValueMap
ccvbus _ _ = error "Control parameter 'ccv' can't be sent to a bus."

-- | choose the channel the pattern is sent to in superdirt
channel :: Pattern p => p Int -> p ValueMap
channel = pI "channel"
channelTake :: Pattern p => String -> [Double] -> p ValueMap
channelTake name xs = pStateListF "channel" name xs
channelCount :: Pattern p => String -> p ValueMap
channelCount name = pStateF "channel" name (maybe 0 (+1))
channelCountTo :: Pattern p => String -> p Double -> p ValueMap
channelCountTo name ipat = innerJoin $ (\i -> pStateF "channel" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

channelbus :: Pattern p => p Int -> p Int -> p ValueMap
channelbus _ _ = error "Control parameter 'channel' can't be sent to a bus."

-- |
clhatdecay :: Pattern p => p Double -> p ValueMap
clhatdecay = pF "clhatdecay"
clhatdecayTake :: Pattern p => String -> [Double] -> p ValueMap
clhatdecayTake name xs = pStateListF "clhatdecay" name xs
clhatdecayCount :: Pattern p => String -> p ValueMap
clhatdecayCount name = pStateF "clhatdecay" name (maybe 0 (+1))
clhatdecayCountTo :: Pattern p => String -> p Double -> p ValueMap
clhatdecayCountTo name ipat = innerJoin $ (\i -> pStateF "clhatdecay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

clhatdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
clhatdecaybus busid pat = pF "clhatdecay" pat # pI "^clhatdecay" busid
clhatdecayrecv :: Pattern p => p Int -> p ValueMap
clhatdecayrecv busid = pI "^clhatdecay" busid

-- | fake-resampling, a pattern of numbers for lowering the sample rate, i.e. 1 for original 2 for half, 3 for a third and so on.
coarse :: Pattern p => p Double -> p ValueMap
coarse = pF "coarse"
coarseTake :: Pattern p => String -> [Double] -> p ValueMap
coarseTake name xs = pStateListF "coarse" name xs
coarseCount :: Pattern p => String -> p ValueMap
coarseCount name = pStateF "coarse" name (maybe 0 (+1))
coarseCountTo :: Pattern p => String -> p Double -> p ValueMap
coarseCountTo name ipat = innerJoin $ (\i -> pStateF "coarse" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

coarsebus :: Pattern p => p Int -> p Double -> p ValueMap
coarsebus busid pat = pF "coarse" pat # pI "^coarse" busid
coarserecv :: Pattern p => p Int -> p ValueMap
coarserecv busid = pI "^coarse" busid

-- | Spectral comb
comb :: Pattern p => p Double -> p ValueMap
comb = pF "comb"
combTake :: Pattern p => String -> [Double] -> p ValueMap
combTake name xs = pStateListF "comb" name xs
combCount :: Pattern p => String -> p ValueMap
combCount name = pStateF "comb" name (maybe 0 (+1))
combCountTo :: Pattern p => String -> p Double -> p ValueMap
combCountTo name ipat = innerJoin $ (\i -> pStateF "comb" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

combbus :: Pattern p => p Int -> p Double -> p ValueMap
combbus busid pat = pF "comb" pat # pI "^comb" busid
combrecv :: Pattern p => p Int -> p ValueMap
combrecv busid = pI "^comb" busid

-- |
control :: Pattern p => p Double -> p ValueMap
control = pF "control"
controlTake :: Pattern p => String -> [Double] -> p ValueMap
controlTake name xs = pStateListF "control" name xs
controlCount :: Pattern p => String -> p ValueMap
controlCount name = pStateF "control" name (maybe 0 (+1))
controlCountTo :: Pattern p => String -> p Double -> p ValueMap
controlCountTo name ipat = innerJoin $ (\i -> pStateF "control" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

controlbus :: Pattern p => p Int -> p Double -> p ValueMap
controlbus _ _ = error "Control parameter 'control' can't be sent to a bus."

-- |
cps :: Pattern p => p Double -> p ValueMap
cps = pF "cps"
cpsTake :: Pattern p => String -> [Double] -> p ValueMap
cpsTake name xs = pStateListF "cps" name xs
cpsCount :: Pattern p => String -> p ValueMap
cpsCount name = pStateF "cps" name (maybe 0 (+1))
cpsCountTo :: Pattern p => String -> p Double -> p ValueMap
cpsCountTo name ipat = innerJoin $ (\i -> pStateF "cps" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

cpsbus :: Pattern p => p Int -> p Double -> p ValueMap
cpsbus busid pat = pF "cps" pat # pI "^cps" busid
cpsrecv :: Pattern p => p Int -> p ValueMap
cpsrecv busid = pI "^cps" busid

-- | bit crushing, a pattern of numbers from 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).
crush :: Pattern p => p Double -> p ValueMap
crush = pF "crush"
crushTake :: Pattern p => String -> [Double] -> p ValueMap
crushTake name xs = pStateListF "crush" name xs
crushCount :: Pattern p => String -> p ValueMap
crushCount name = pStateF "crush" name (maybe 0 (+1))
crushCountTo :: Pattern p => String -> p Double -> p ValueMap
crushCountTo name ipat = innerJoin $ (\i -> pStateF "crush" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

crushbus :: Pattern p => p Int -> p Double -> p ValueMap
crushbus busid pat = pF "crush" pat # pI "^crush" busid
crushrecv :: Pattern p => p Int -> p ValueMap
crushrecv busid = pI "^crush" busid

-- |
ctlNum :: Pattern p => p Double -> p ValueMap
ctlNum = pF "ctlNum"
ctlNumTake :: Pattern p => String -> [Double] -> p ValueMap
ctlNumTake name xs = pStateListF "ctlNum" name xs
ctlNumCount :: Pattern p => String -> p ValueMap
ctlNumCount name = pStateF "ctlNum" name (maybe 0 (+1))
ctlNumCountTo :: Pattern p => String -> p Double -> p ValueMap
ctlNumCountTo name ipat = innerJoin $ (\i -> pStateF "ctlNum" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ctlNumbus :: Pattern p => p Int -> p Double -> p ValueMap
ctlNumbus _ _ = error "Control parameter 'ctlNum' can't be sent to a bus."

-- |
ctranspose :: Pattern p => p Double -> p ValueMap
ctranspose = pF "ctranspose"
ctransposeTake :: Pattern p => String -> [Double] -> p ValueMap
ctransposeTake name xs = pStateListF "ctranspose" name xs
ctransposeCount :: Pattern p => String -> p ValueMap
ctransposeCount name = pStateF "ctranspose" name (maybe 0 (+1))
ctransposeCountTo :: Pattern p => String -> p Double -> p ValueMap
ctransposeCountTo name ipat = innerJoin $ (\i -> pStateF "ctranspose" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ctransposebus :: Pattern p => p Int -> p Double -> p ValueMap
ctransposebus busid pat = pF "ctranspose" pat # pI "^ctranspose" busid
ctransposerecv :: Pattern p => p Int -> p ValueMap
ctransposerecv busid = pI "^ctranspose" busid

-- | In the style of classic drum-machines, `cut` will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.
cut :: Pattern p => p Int -> p ValueMap
cut = pI "cut"
cutTake :: Pattern p => String -> [Double] -> p ValueMap
cutTake name xs = pStateListF "cut" name xs
cutCount :: Pattern p => String -> p ValueMap
cutCount name = pStateF "cut" name (maybe 0 (+1))
cutCountTo :: Pattern p => String -> p Double -> p ValueMap
cutCountTo name ipat = innerJoin $ (\i -> pStateF "cut" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

cutbus :: Pattern p => p Int -> p Int -> p ValueMap
cutbus busid pat = pI "cut" pat # pI "^cut" busid
cutrecv :: Pattern p => p Int -> p ValueMap
cutrecv busid = pI "^cut" busid

-- | a pattern of numbers from 0 to 1. Applies the cutoff frequency of the low-pass filter.
cutoff :: Pattern p => p Double -> p ValueMap
cutoff = pF "cutoff"
cutoffTake :: Pattern p => String -> [Double] -> p ValueMap
cutoffTake name xs = pStateListF "cutoff" name xs
cutoffCount :: Pattern p => String -> p ValueMap
cutoffCount name = pStateF "cutoff" name (maybe 0 (+1))
cutoffCountTo :: Pattern p => String -> p Double -> p ValueMap
cutoffCountTo name ipat = innerJoin $ (\i -> pStateF "cutoff" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

cutoffbus :: Pattern p => p Int -> p Double -> p ValueMap
cutoffbus busid pat = pF "cutoff" pat # pI "^cutoff" busid
cutoffrecv :: Pattern p => p Int -> p ValueMap
cutoffrecv busid = pI "^cutoff" busid

-- |
cutoffegint :: Pattern p => p Double -> p ValueMap
cutoffegint = pF "cutoffegint"
cutoffegintTake :: Pattern p => String -> [Double] -> p ValueMap
cutoffegintTake name xs = pStateListF "cutoffegint" name xs
cutoffegintCount :: Pattern p => String -> p ValueMap
cutoffegintCount name = pStateF "cutoffegint" name (maybe 0 (+1))
cutoffegintCountTo :: Pattern p => String -> p Double -> p ValueMap
cutoffegintCountTo name ipat = innerJoin $ (\i -> pStateF "cutoffegint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

cutoffegintbus :: Pattern p => p Int -> p Double -> p ValueMap
cutoffegintbus busid pat = pF "cutoffegint" pat # pI "^cutoffegint" busid
cutoffegintrecv :: Pattern p => p Int -> p ValueMap
cutoffegintrecv busid = pI "^cutoffegint" busid

-- |
decay :: Pattern p => p Double -> p ValueMap
decay = pF "decay"
decayTake :: Pattern p => String -> [Double] -> p ValueMap
decayTake name xs = pStateListF "decay" name xs
decayCount :: Pattern p => String -> p ValueMap
decayCount name = pStateF "decay" name (maybe 0 (+1))
decayCountTo :: Pattern p => String -> p Double -> p ValueMap
decayCountTo name ipat = innerJoin $ (\i -> pStateF "decay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

decaybus :: Pattern p => p Int -> p Double -> p ValueMap
decaybus busid pat = pF "decay" pat # pI "^decay" busid
decayrecv :: Pattern p => p Int -> p ValueMap
decayrecv busid = pI "^decay" busid

-- |
degree :: Pattern p => p Double -> p ValueMap
degree = pF "degree"
degreeTake :: Pattern p => String -> [Double] -> p ValueMap
degreeTake name xs = pStateListF "degree" name xs
degreeCount :: Pattern p => String -> p ValueMap
degreeCount name = pStateF "degree" name (maybe 0 (+1))
degreeCountTo :: Pattern p => String -> p Double -> p ValueMap
degreeCountTo name ipat = innerJoin $ (\i -> pStateF "degree" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

degreebus :: Pattern p => p Int -> p Double -> p ValueMap
degreebus busid pat = pF "degree" pat # pI "^degree" busid
degreerecv :: Pattern p => p Int -> p ValueMap
degreerecv busid = pI "^degree" busid

-- | a pattern of numbers from 0 to 1. Sets the level of the delay signal.
delay :: Pattern p => p Double -> p ValueMap
delay = pF "delay"
delayTake :: Pattern p => String -> [Double] -> p ValueMap
delayTake name xs = pStateListF "delay" name xs
delayCount :: Pattern p => String -> p ValueMap
delayCount name = pStateF "delay" name (maybe 0 (+1))
delayCountTo :: Pattern p => String -> p Double -> p ValueMap
delayCountTo name ipat = innerJoin $ (\i -> pStateF "delay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

delaybus :: Pattern p => p Int -> p Double -> p ValueMap
delaybus busid pat = pF "delay" pat # pI "^delay" busid
delayrecv :: Pattern p => p Int -> p ValueMap
delayrecv busid = pI "^delay" busid

-- | a pattern of numbers from 0 to 1. Sets the amount of delay feedback.
delayfeedback :: Pattern p => p Double -> p ValueMap
delayfeedback = pF "delayfeedback"
delayfeedbackTake :: Pattern p => String -> [Double] -> p ValueMap
delayfeedbackTake name xs = pStateListF "delayfeedback" name xs
delayfeedbackCount :: Pattern p => String -> p ValueMap
delayfeedbackCount name = pStateF "delayfeedback" name (maybe 0 (+1))
delayfeedbackCountTo :: Pattern p => String -> p Double -> p ValueMap
delayfeedbackCountTo name ipat = innerJoin $ (\i -> pStateF "delayfeedback" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

delayfeedbackbus :: Pattern p => p Int -> p Double -> p ValueMap
delayfeedbackbus busid pat = pF "delayfeedback" pat # pI "^delayfeedback" busid
delayfeedbackrecv :: Pattern p => p Int -> p ValueMap
delayfeedbackrecv busid = pI "^delayfeedback" busid

-- | a pattern of numbers from 0 to 1. Sets the length of the delay.
delaytime :: Pattern p => p Double -> p ValueMap
delaytime = pF "delaytime"
delaytimeTake :: Pattern p => String -> [Double] -> p ValueMap
delaytimeTake name xs = pStateListF "delaytime" name xs
delaytimeCount :: Pattern p => String -> p ValueMap
delaytimeCount name = pStateF "delaytime" name (maybe 0 (+1))
delaytimeCountTo :: Pattern p => String -> p Double -> p ValueMap
delaytimeCountTo name ipat = innerJoin $ (\i -> pStateF "delaytime" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

delaytimebus :: Pattern p => p Int -> p Double -> p ValueMap
delaytimebus busid pat = pF "delaytime" pat # pI "^delaytime" busid
delaytimerecv :: Pattern p => p Int -> p ValueMap
delaytimerecv busid = pI "^delaytime" busid

-- |
detune :: Pattern p => p Double -> p ValueMap
detune = pF "detune"
detuneTake :: Pattern p => String -> [Double] -> p ValueMap
detuneTake name xs = pStateListF "detune" name xs
detuneCount :: Pattern p => String -> p ValueMap
detuneCount name = pStateF "detune" name (maybe 0 (+1))
detuneCountTo :: Pattern p => String -> p Double -> p ValueMap
detuneCountTo name ipat = innerJoin $ (\i -> pStateF "detune" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

detunebus :: Pattern p => p Int -> p Double -> p ValueMap
detunebus busid pat = pF "detune" pat # pI "^detune" busid
detunerecv :: Pattern p => p Int -> p ValueMap
detunerecv busid = pI "^detune" busid

-- | noisy fuzzy distortion
distort :: Pattern p => p Double -> p ValueMap
distort = pF "distort"
distortTake :: Pattern p => String -> [Double] -> p ValueMap
distortTake name xs = pStateListF "distort" name xs
distortCount :: Pattern p => String -> p ValueMap
distortCount name = pStateF "distort" name (maybe 0 (+1))
distortCountTo :: Pattern p => String -> p Double -> p ValueMap
distortCountTo name ipat = innerJoin $ (\i -> pStateF "distort" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

distortbus :: Pattern p => p Int -> p Double -> p ValueMap
distortbus busid pat = pF "distort" pat # pI "^distort" busid
distortrecv :: Pattern p => p Int -> p ValueMap
distortrecv busid = pI "^distort" busid

-- | DJ filter, below 0.5 is low pass filter, above is high pass filter.
djf :: Pattern p => p Double -> p ValueMap
djf = pF "djf"
djfTake :: Pattern p => String -> [Double] -> p ValueMap
djfTake name xs = pStateListF "djf" name xs
djfCount :: Pattern p => String -> p ValueMap
djfCount name = pStateF "djf" name (maybe 0 (+1))
djfCountTo :: Pattern p => String -> p Double -> p ValueMap
djfCountTo name ipat = innerJoin $ (\i -> pStateF "djf" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

djfbus :: Pattern p => p Int -> p Double -> p ValueMap
djfbus busid pat = pF "djf" pat # pI "^djf" busid
djfrecv :: Pattern p => p Int -> p ValueMap
djfrecv busid = pI "^djf" busid

-- | when set to `1` will disable all reverb for this pattern. See `room` and `size` for more information about reverb.
dry :: Pattern p => p Double -> p ValueMap
dry = pF "dry"
dryTake :: Pattern p => String -> [Double] -> p ValueMap
dryTake name xs = pStateListF "dry" name xs
dryCount :: Pattern p => String -> p ValueMap
dryCount name = pStateF "dry" name (maybe 0 (+1))
dryCountTo :: Pattern p => String -> p Double -> p ValueMap
dryCountTo name ipat = innerJoin $ (\i -> pStateF "dry" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

drybus :: Pattern p => p Int -> p Double -> p ValueMap
drybus busid pat = pF "dry" pat # pI "^dry" busid
dryrecv :: Pattern p => p Int -> p ValueMap
dryrecv busid = pI "^dry" busid

-- |
dur :: Pattern p => p Double -> p ValueMap
dur = pF "dur"
durTake :: Pattern p => String -> [Double] -> p ValueMap
durTake name xs = pStateListF "dur" name xs
durCount :: Pattern p => String -> p ValueMap
durCount name = pStateF "dur" name (maybe 0 (+1))
durCountTo :: Pattern p => String -> p Double -> p ValueMap
durCountTo name ipat = innerJoin $ (\i -> pStateF "dur" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

durbus :: Pattern p => p Int -> p Double -> p ValueMap
durbus busid pat = pF "dur" pat # pI "^dur" busid
durrecv :: Pattern p => p Int -> p ValueMap
durrecv busid = pI "^dur" busid

-- | the same as `begin`, but cuts the end off samples, shortening them; e.g. `0.75` to cut off the last quarter of each sample.
end :: Pattern p => p Double -> p ValueMap
end = pF "end"
endTake :: Pattern p => String -> [Double] -> p ValueMap
endTake name xs = pStateListF "end" name xs
endCount :: Pattern p => String -> p ValueMap
endCount name = pStateF "end" name (maybe 0 (+1))
endCountTo :: Pattern p => String -> p Double -> p ValueMap
endCountTo name ipat = innerJoin $ (\i -> pStateF "end" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

endbus :: Pattern p => p Int -> p Double -> p ValueMap
endbus _ _ = error "Control parameter 'end' can't be sent to a bus."

-- | Spectral enhance
enhance :: Pattern p => p Double -> p ValueMap
enhance = pF "enhance"
enhanceTake :: Pattern p => String -> [Double] -> p ValueMap
enhanceTake name xs = pStateListF "enhance" name xs
enhanceCount :: Pattern p => String -> p ValueMap
enhanceCount name = pStateF "enhance" name (maybe 0 (+1))
enhanceCountTo :: Pattern p => String -> p Double -> p ValueMap
enhanceCountTo name ipat = innerJoin $ (\i -> pStateF "enhance" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

enhancebus :: Pattern p => p Int -> p Double -> p ValueMap
enhancebus busid pat = pF "enhance" pat # pI "^enhance" busid
enhancerecv :: Pattern p => p Int -> p ValueMap
enhancerecv busid = pI "^enhance" busid

-- |
expression :: Pattern p => p Double -> p ValueMap
expression = pF "expression"
expressionTake :: Pattern p => String -> [Double] -> p ValueMap
expressionTake name xs = pStateListF "expression" name xs
expressionCount :: Pattern p => String -> p ValueMap
expressionCount name = pStateF "expression" name (maybe 0 (+1))
expressionCountTo :: Pattern p => String -> p Double -> p ValueMap
expressionCountTo name ipat = innerJoin $ (\i -> pStateF "expression" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

expressionbus :: Pattern p => p Int -> p Double -> p ValueMap
expressionbus busid pat = pF "expression" pat # pI "^expression" busid
expressionrecv :: Pattern p => p Int -> p ValueMap
expressionrecv busid = pI "^expression" busid

-- | As with fadeTime, but controls the fade in time of the grain envelope. Not used if the grain begins at position 0 in the sample.
fadeInTime :: Pattern p => p Double -> p ValueMap
fadeInTime = pF "fadeInTime"
fadeInTimeTake :: Pattern p => String -> [Double] -> p ValueMap
fadeInTimeTake name xs = pStateListF "fadeInTime" name xs
fadeInTimeCount :: Pattern p => String -> p ValueMap
fadeInTimeCount name = pStateF "fadeInTime" name (maybe 0 (+1))
fadeInTimeCountTo :: Pattern p => String -> p Double -> p ValueMap
fadeInTimeCountTo name ipat = innerJoin $ (\i -> pStateF "fadeInTime" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

fadeInTimebus :: Pattern p => p Int -> p Double -> p ValueMap
fadeInTimebus _ _ = error "Control parameter 'fadeInTime' can't be sent to a bus."

-- | Used when using begin/end or chop/striate and friends, to change the fade out time of the 'grain' envelope.
fadeTime :: Pattern p => p Double -> p ValueMap
fadeTime = pF "fadeTime"
fadeTimeTake :: Pattern p => String -> [Double] -> p ValueMap
fadeTimeTake name xs = pStateListF "fadeTime" name xs
fadeTimeCount :: Pattern p => String -> p ValueMap
fadeTimeCount name = pStateF "fadeTime" name (maybe 0 (+1))
fadeTimeCountTo :: Pattern p => String -> p Double -> p ValueMap
fadeTimeCountTo name ipat = innerJoin $ (\i -> pStateF "fadeTime" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

fadeTimebus :: Pattern p => p Int -> p Double -> p ValueMap
fadeTimebus _ _ = error "Control parameter 'fadeTime' can't be sent to a bus."

-- |
frameRate :: Pattern p => p Double -> p ValueMap
frameRate = pF "frameRate"
frameRateTake :: Pattern p => String -> [Double] -> p ValueMap
frameRateTake name xs = pStateListF "frameRate" name xs
frameRateCount :: Pattern p => String -> p ValueMap
frameRateCount name = pStateF "frameRate" name (maybe 0 (+1))
frameRateCountTo :: Pattern p => String -> p Double -> p ValueMap
frameRateCountTo name ipat = innerJoin $ (\i -> pStateF "frameRate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

frameRatebus :: Pattern p => p Int -> p Double -> p ValueMap
frameRatebus _ _ = error "Control parameter 'frameRate' can't be sent to a bus."

-- |
frames :: Pattern p => p Double -> p ValueMap
frames = pF "frames"
framesTake :: Pattern p => String -> [Double] -> p ValueMap
framesTake name xs = pStateListF "frames" name xs
framesCount :: Pattern p => String -> p ValueMap
framesCount name = pStateF "frames" name (maybe 0 (+1))
framesCountTo :: Pattern p => String -> p Double -> p ValueMap
framesCountTo name ipat = innerJoin $ (\i -> pStateF "frames" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

framesbus :: Pattern p => p Int -> p Double -> p ValueMap
framesbus _ _ = error "Control parameter 'frames' can't be sent to a bus."

-- | Spectral freeze
freeze :: Pattern p => p Double -> p ValueMap
freeze = pF "freeze"
freezeTake :: Pattern p => String -> [Double] -> p ValueMap
freezeTake name xs = pStateListF "freeze" name xs
freezeCount :: Pattern p => String -> p ValueMap
freezeCount name = pStateF "freeze" name (maybe 0 (+1))
freezeCountTo :: Pattern p => String -> p Double -> p ValueMap
freezeCountTo name ipat = innerJoin $ (\i -> pStateF "freeze" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

freezebus :: Pattern p => p Int -> p Double -> p ValueMap
freezebus busid pat = pF "freeze" pat # pI "^freeze" busid
freezerecv :: Pattern p => p Int -> p ValueMap
freezerecv busid = pI "^freeze" busid

-- |
freq :: Pattern p => p Double -> p ValueMap
freq = pF "freq"
freqTake :: Pattern p => String -> [Double] -> p ValueMap
freqTake name xs = pStateListF "freq" name xs
freqCount :: Pattern p => String -> p ValueMap
freqCount name = pStateF "freq" name (maybe 0 (+1))
freqCountTo :: Pattern p => String -> p Double -> p ValueMap
freqCountTo name ipat = innerJoin $ (\i -> pStateF "freq" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

freqbus :: Pattern p => p Int -> p Double -> p ValueMap
freqbus busid pat = pF "freq" pat # pI "^freq" busid
freqrecv :: Pattern p => p Int -> p ValueMap
freqrecv busid = pI "^freq" busid

-- | for internal sound routing
from :: Pattern p => p Double -> p ValueMap
from = pF "from"
fromTake :: Pattern p => String -> [Double] -> p ValueMap
fromTake name xs = pStateListF "from" name xs
fromCount :: Pattern p => String -> p ValueMap
fromCount name = pStateF "from" name (maybe 0 (+1))
fromCountTo :: Pattern p => String -> p Double -> p ValueMap
fromCountTo name ipat = innerJoin $ (\i -> pStateF "from" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

frombus :: Pattern p => p Int -> p Double -> p ValueMap
frombus busid pat = pF "from" pat # pI "^from" busid
fromrecv :: Pattern p => p Int -> p ValueMap
fromrecv busid = pI "^from" busid

-- | frequency shifter
fshift :: Pattern p => p Double -> p ValueMap
fshift = pF "fshift"
fshiftTake :: Pattern p => String -> [Double] -> p ValueMap
fshiftTake name xs = pStateListF "fshift" name xs
fshiftCount :: Pattern p => String -> p ValueMap
fshiftCount name = pStateF "fshift" name (maybe 0 (+1))
fshiftCountTo :: Pattern p => String -> p Double -> p ValueMap
fshiftCountTo name ipat = innerJoin $ (\i -> pStateF "fshift" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

fshiftbus :: Pattern p => p Int -> p Double -> p ValueMap
fshiftbus busid pat = pF "fshift" pat # pI "^fshift" busid
fshiftrecv :: Pattern p => p Int -> p ValueMap
fshiftrecv busid = pI "^fshift" busid

-- | frequency shifter
fshiftnote :: Pattern p => p Double -> p ValueMap
fshiftnote = pF "fshiftnote"
fshiftnoteTake :: Pattern p => String -> [Double] -> p ValueMap
fshiftnoteTake name xs = pStateListF "fshiftnote" name xs
fshiftnoteCount :: Pattern p => String -> p ValueMap
fshiftnoteCount name = pStateF "fshiftnote" name (maybe 0 (+1))
fshiftnoteCountTo :: Pattern p => String -> p Double -> p ValueMap
fshiftnoteCountTo name ipat = innerJoin $ (\i -> pStateF "fshiftnote" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

fshiftnotebus :: Pattern p => p Int -> p Double -> p ValueMap
fshiftnotebus busid pat = pF "fshiftnote" pat # pI "^fshiftnote" busid
fshiftnoterecv :: Pattern p => p Int -> p ValueMap
fshiftnoterecv busid = pI "^fshiftnote" busid

-- | frequency shifter
fshiftphase :: Pattern p => p Double -> p ValueMap
fshiftphase = pF "fshiftphase"
fshiftphaseTake :: Pattern p => String -> [Double] -> p ValueMap
fshiftphaseTake name xs = pStateListF "fshiftphase" name xs
fshiftphaseCount :: Pattern p => String -> p ValueMap
fshiftphaseCount name = pStateF "fshiftphase" name (maybe 0 (+1))
fshiftphaseCountTo :: Pattern p => String -> p Double -> p ValueMap
fshiftphaseCountTo name ipat = innerJoin $ (\i -> pStateF "fshiftphase" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

fshiftphasebus :: Pattern p => p Int -> p Double -> p ValueMap
fshiftphasebus busid pat = pF "fshiftphase" pat # pI "^fshiftphase" busid
fshiftphaserecv :: Pattern p => p Int -> p ValueMap
fshiftphaserecv busid = pI "^fshiftphase" busid

-- | a pattern of numbers that specify volume. Values less than 1 make the sound quieter. Values greater than 1 make the sound louder. For the linear equivalent, see @amp@.
gain :: Pattern p => p Double -> p ValueMap
gain = pF "gain"
gainTake :: Pattern p => String -> [Double] -> p ValueMap
gainTake name xs = pStateListF "gain" name xs
gainCount :: Pattern p => String -> p ValueMap
gainCount name = pStateF "gain" name (maybe 0 (+1))
gainCountTo :: Pattern p => String -> p Double -> p ValueMap
gainCountTo name ipat = innerJoin $ (\i -> pStateF "gain" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

gainbus :: Pattern p => p Int -> p Double -> p ValueMap
gainbus _ _ = error "Control parameter 'gain' can't be sent to a bus."

-- |
gate :: Pattern p => p Double -> p ValueMap
gate = pF "gate"
gateTake :: Pattern p => String -> [Double] -> p ValueMap
gateTake name xs = pStateListF "gate" name xs
gateCount :: Pattern p => String -> p ValueMap
gateCount name = pStateF "gate" name (maybe 0 (+1))
gateCountTo :: Pattern p => String -> p Double -> p ValueMap
gateCountTo name ipat = innerJoin $ (\i -> pStateF "gate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

gatebus :: Pattern p => p Int -> p Double -> p ValueMap
gatebus busid pat = pF "gate" pat # pI "^gate" busid
gaterecv :: Pattern p => p Int -> p ValueMap
gaterecv busid = pI "^gate" busid

-- |
harmonic :: Pattern p => p Double -> p ValueMap
harmonic = pF "harmonic"
harmonicTake :: Pattern p => String -> [Double] -> p ValueMap
harmonicTake name xs = pStateListF "harmonic" name xs
harmonicCount :: Pattern p => String -> p ValueMap
harmonicCount name = pStateF "harmonic" name (maybe 0 (+1))
harmonicCountTo :: Pattern p => String -> p Double -> p ValueMap
harmonicCountTo name ipat = innerJoin $ (\i -> pStateF "harmonic" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

harmonicbus :: Pattern p => p Int -> p Double -> p ValueMap
harmonicbus busid pat = pF "harmonic" pat # pI "^harmonic" busid
harmonicrecv :: Pattern p => p Int -> p ValueMap
harmonicrecv busid = pI "^harmonic" busid

-- |
hatgrain :: Pattern p => p Double -> p ValueMap
hatgrain = pF "hatgrain"
hatgrainTake :: Pattern p => String -> [Double] -> p ValueMap
hatgrainTake name xs = pStateListF "hatgrain" name xs
hatgrainCount :: Pattern p => String -> p ValueMap
hatgrainCount name = pStateF "hatgrain" name (maybe 0 (+1))
hatgrainCountTo :: Pattern p => String -> p Double -> p ValueMap
hatgrainCountTo name ipat = innerJoin $ (\i -> pStateF "hatgrain" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

hatgrainbus :: Pattern p => p Int -> p Double -> p ValueMap
hatgrainbus busid pat = pF "hatgrain" pat # pI "^hatgrain" busid
hatgrainrecv :: Pattern p => p Int -> p ValueMap
hatgrainrecv busid = pI "^hatgrain" busid

-- | High pass sort of spectral filter
hbrick :: Pattern p => p Double -> p ValueMap
hbrick = pF "hbrick"
hbrickTake :: Pattern p => String -> [Double] -> p ValueMap
hbrickTake name xs = pStateListF "hbrick" name xs
hbrickCount :: Pattern p => String -> p ValueMap
hbrickCount name = pStateF "hbrick" name (maybe 0 (+1))
hbrickCountTo :: Pattern p => String -> p Double -> p ValueMap
hbrickCountTo name ipat = innerJoin $ (\i -> pStateF "hbrick" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

hbrickbus :: Pattern p => p Int -> p Double -> p ValueMap
hbrickbus busid pat = pF "hbrick" pat # pI "^hbrick" busid
hbrickrecv :: Pattern p => p Int -> p ValueMap
hbrickrecv busid = pI "^hbrick" busid

-- | a pattern of numbers from 0 to 1. Applies the cutoff frequency of the high-pass filter. Also has alias @hpf@
hcutoff :: Pattern p => p Double -> p ValueMap
hcutoff = pF "hcutoff"
hcutoffTake :: Pattern p => String -> [Double] -> p ValueMap
hcutoffTake name xs = pStateListF "hcutoff" name xs
hcutoffCount :: Pattern p => String -> p ValueMap
hcutoffCount name = pStateF "hcutoff" name (maybe 0 (+1))
hcutoffCountTo :: Pattern p => String -> p Double -> p ValueMap
hcutoffCountTo name ipat = innerJoin $ (\i -> pStateF "hcutoff" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

hcutoffbus :: Pattern p => p Int -> p Double -> p ValueMap
hcutoffbus busid pat = pF "hcutoff" pat # pI "^hcutoff" busid
hcutoffrecv :: Pattern p => p Int -> p ValueMap
hcutoffrecv busid = pI "^hcutoff" busid

-- | a pattern of numbers to specify the hold time (in seconds) of an envelope applied to each sample. Only takes effect if `attack` and `release` are also specified.
hold :: Pattern p => p Double -> p ValueMap
hold = pF "hold"
holdTake :: Pattern p => String -> [Double] -> p ValueMap
holdTake name xs = pStateListF "hold" name xs
holdCount :: Pattern p => String -> p ValueMap
holdCount name = pStateF "hold" name (maybe 0 (+1))
holdCountTo :: Pattern p => String -> p Double -> p ValueMap
holdCountTo name ipat = innerJoin $ (\i -> pStateF "hold" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

holdbus :: Pattern p => p Int -> p Double -> p ValueMap
holdbus busid pat = pF "hold" pat # pI "^hold" busid
holdrecv :: Pattern p => p Int -> p ValueMap
holdrecv busid = pI "^hold" busid

-- |
hours :: Pattern p => p Double -> p ValueMap
hours = pF "hours"
hoursTake :: Pattern p => String -> [Double] -> p ValueMap
hoursTake name xs = pStateListF "hours" name xs
hoursCount :: Pattern p => String -> p ValueMap
hoursCount name = pStateF "hours" name (maybe 0 (+1))
hoursCountTo :: Pattern p => String -> p Double -> p ValueMap
hoursCountTo name ipat = innerJoin $ (\i -> pStateF "hours" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

hoursbus :: Pattern p => p Int -> p Double -> p ValueMap
hoursbus _ _ = error "Control parameter 'hours' can't be sent to a bus."

-- | a pattern of numbers from 0 to 1. Applies the resonance of the high-pass filter. Has alias @hpq@
hresonance :: Pattern p => p Double -> p ValueMap
hresonance = pF "hresonance"
hresonanceTake :: Pattern p => String -> [Double] -> p ValueMap
hresonanceTake name xs = pStateListF "hresonance" name xs
hresonanceCount :: Pattern p => String -> p ValueMap
hresonanceCount name = pStateF "hresonance" name (maybe 0 (+1))
hresonanceCountTo :: Pattern p => String -> p Double -> p ValueMap
hresonanceCountTo name ipat = innerJoin $ (\i -> pStateF "hresonance" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

hresonancebus :: Pattern p => p Int -> p Double -> p ValueMap
hresonancebus busid pat = pF "hresonance" pat # pI "^hresonance" busid
hresonancerecv :: Pattern p => p Int -> p ValueMap
hresonancerecv busid = pI "^hresonance" busid

-- |
imag :: Pattern p => p Double -> p ValueMap
imag = pF "imag"
imagTake :: Pattern p => String -> [Double] -> p ValueMap
imagTake name xs = pStateListF "imag" name xs
imagCount :: Pattern p => String -> p ValueMap
imagCount name = pStateF "imag" name (maybe 0 (+1))
imagCountTo :: Pattern p => String -> p Double -> p ValueMap
imagCountTo name ipat = innerJoin $ (\i -> pStateF "imag" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

imagbus :: Pattern p => p Int -> p Double -> p ValueMap
imagbus busid pat = pF "imag" pat # pI "^imag" busid
imagrecv :: Pattern p => p Int -> p ValueMap
imagrecv busid = pI "^imag" busid

-- |
kcutoff :: Pattern p => p Double -> p ValueMap
kcutoff = pF "kcutoff"
kcutoffTake :: Pattern p => String -> [Double] -> p ValueMap
kcutoffTake name xs = pStateListF "kcutoff" name xs
kcutoffCount :: Pattern p => String -> p ValueMap
kcutoffCount name = pStateF "kcutoff" name (maybe 0 (+1))
kcutoffCountTo :: Pattern p => String -> p Double -> p ValueMap
kcutoffCountTo name ipat = innerJoin $ (\i -> pStateF "kcutoff" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

kcutoffbus :: Pattern p => p Int -> p Double -> p ValueMap
kcutoffbus busid pat = pF "kcutoff" pat # pI "^kcutoff" busid
kcutoffrecv :: Pattern p => p Int -> p ValueMap
kcutoffrecv busid = pI "^kcutoff" busid

-- | shape/bass enhancer
krush :: Pattern p => p Double -> p ValueMap
krush = pF "krush"
krushTake :: Pattern p => String -> [Double] -> p ValueMap
krushTake name xs = pStateListF "krush" name xs
krushCount :: Pattern p => String -> p ValueMap
krushCount name = pStateF "krush" name (maybe 0 (+1))
krushCountTo :: Pattern p => String -> p Double -> p ValueMap
krushCountTo name ipat = innerJoin $ (\i -> pStateF "krush" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

krushbus :: Pattern p => p Int -> p Double -> p ValueMap
krushbus busid pat = pF "krush" pat # pI "^krush" busid
krushrecv :: Pattern p => p Int -> p ValueMap
krushrecv busid = pI "^krush" busid

-- |
lagogo :: Pattern p => p Double -> p ValueMap
lagogo = pF "lagogo"
lagogoTake :: Pattern p => String -> [Double] -> p ValueMap
lagogoTake name xs = pStateListF "lagogo" name xs
lagogoCount :: Pattern p => String -> p ValueMap
lagogoCount name = pStateF "lagogo" name (maybe 0 (+1))
lagogoCountTo :: Pattern p => String -> p Double -> p ValueMap
lagogoCountTo name ipat = innerJoin $ (\i -> pStateF "lagogo" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lagogobus :: Pattern p => p Int -> p Double -> p ValueMap
lagogobus busid pat = pF "lagogo" pat # pI "^lagogo" busid
lagogorecv :: Pattern p => p Int -> p ValueMap
lagogorecv busid = pI "^lagogo" busid

-- | Low pass sort of spectral filter
lbrick :: Pattern p => p Double -> p ValueMap
lbrick = pF "lbrick"
lbrickTake :: Pattern p => String -> [Double] -> p ValueMap
lbrickTake name xs = pStateListF "lbrick" name xs
lbrickCount :: Pattern p => String -> p ValueMap
lbrickCount name = pStateF "lbrick" name (maybe 0 (+1))
lbrickCountTo :: Pattern p => String -> p Double -> p ValueMap
lbrickCountTo name ipat = innerJoin $ (\i -> pStateF "lbrick" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lbrickbus :: Pattern p => p Int -> p Double -> p ValueMap
lbrickbus busid pat = pF "lbrick" pat # pI "^lbrick" busid
lbrickrecv :: Pattern p => p Int -> p ValueMap
lbrickrecv busid = pI "^lbrick" busid

-- |
lclap :: Pattern p => p Double -> p ValueMap
lclap = pF "lclap"
lclapTake :: Pattern p => String -> [Double] -> p ValueMap
lclapTake name xs = pStateListF "lclap" name xs
lclapCount :: Pattern p => String -> p ValueMap
lclapCount name = pStateF "lclap" name (maybe 0 (+1))
lclapCountTo :: Pattern p => String -> p Double -> p ValueMap
lclapCountTo name ipat = innerJoin $ (\i -> pStateF "lclap" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lclapbus :: Pattern p => p Int -> p Double -> p ValueMap
lclapbus busid pat = pF "lclap" pat # pI "^lclap" busid
lclaprecv :: Pattern p => p Int -> p ValueMap
lclaprecv busid = pI "^lclap" busid

-- |
lclaves :: Pattern p => p Double -> p ValueMap
lclaves = pF "lclaves"
lclavesTake :: Pattern p => String -> [Double] -> p ValueMap
lclavesTake name xs = pStateListF "lclaves" name xs
lclavesCount :: Pattern p => String -> p ValueMap
lclavesCount name = pStateF "lclaves" name (maybe 0 (+1))
lclavesCountTo :: Pattern p => String -> p Double -> p ValueMap
lclavesCountTo name ipat = innerJoin $ (\i -> pStateF "lclaves" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lclavesbus :: Pattern p => p Int -> p Double -> p ValueMap
lclavesbus busid pat = pF "lclaves" pat # pI "^lclaves" busid
lclavesrecv :: Pattern p => p Int -> p ValueMap
lclavesrecv busid = pI "^lclaves" busid

-- |
lclhat :: Pattern p => p Double -> p ValueMap
lclhat = pF "lclhat"
lclhatTake :: Pattern p => String -> [Double] -> p ValueMap
lclhatTake name xs = pStateListF "lclhat" name xs
lclhatCount :: Pattern p => String -> p ValueMap
lclhatCount name = pStateF "lclhat" name (maybe 0 (+1))
lclhatCountTo :: Pattern p => String -> p Double -> p ValueMap
lclhatCountTo name ipat = innerJoin $ (\i -> pStateF "lclhat" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lclhatbus :: Pattern p => p Int -> p Double -> p ValueMap
lclhatbus busid pat = pF "lclhat" pat # pI "^lclhat" busid
lclhatrecv :: Pattern p => p Int -> p ValueMap
lclhatrecv busid = pI "^lclhat" busid

-- |
lcrash :: Pattern p => p Double -> p ValueMap
lcrash = pF "lcrash"
lcrashTake :: Pattern p => String -> [Double] -> p ValueMap
lcrashTake name xs = pStateListF "lcrash" name xs
lcrashCount :: Pattern p => String -> p ValueMap
lcrashCount name = pStateF "lcrash" name (maybe 0 (+1))
lcrashCountTo :: Pattern p => String -> p Double -> p ValueMap
lcrashCountTo name ipat = innerJoin $ (\i -> pStateF "lcrash" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lcrashbus :: Pattern p => p Int -> p Double -> p ValueMap
lcrashbus busid pat = pF "lcrash" pat # pI "^lcrash" busid
lcrashrecv :: Pattern p => p Int -> p ValueMap
lcrashrecv busid = pI "^lcrash" busid

-- | controls the amount of overlap between two adjacent sounds
legato :: Pattern p => p Double -> p ValueMap
legato = pF "legato"
legatoTake :: Pattern p => String -> [Double] -> p ValueMap
legatoTake name xs = pStateListF "legato" name xs
legatoCount :: Pattern p => String -> p ValueMap
legatoCount name = pStateF "legato" name (maybe 0 (+1))
legatoCountTo :: Pattern p => String -> p Double -> p ValueMap
legatoCountTo name ipat = innerJoin $ (\i -> pStateF "legato" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

legatobus :: Pattern p => p Int -> p Double -> p ValueMap
legatobus _ _ = error "Control parameter 'legato' can't be sent to a bus."

-- |
leslie :: Pattern p => p Double -> p ValueMap
leslie = pF "leslie"
leslieTake :: Pattern p => String -> [Double] -> p ValueMap
leslieTake name xs = pStateListF "leslie" name xs
leslieCount :: Pattern p => String -> p ValueMap
leslieCount name = pStateF "leslie" name (maybe 0 (+1))
leslieCountTo :: Pattern p => String -> p Double -> p ValueMap
leslieCountTo name ipat = innerJoin $ (\i -> pStateF "leslie" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lesliebus :: Pattern p => p Int -> p Double -> p ValueMap
lesliebus busid pat = pF "leslie" pat # pI "^leslie" busid
leslierecv :: Pattern p => p Int -> p ValueMap
leslierecv busid = pI "^leslie" busid

-- |
lfo :: Pattern p => p Double -> p ValueMap
lfo = pF "lfo"
lfoTake :: Pattern p => String -> [Double] -> p ValueMap
lfoTake name xs = pStateListF "lfo" name xs
lfoCount :: Pattern p => String -> p ValueMap
lfoCount name = pStateF "lfo" name (maybe 0 (+1))
lfoCountTo :: Pattern p => String -> p Double -> p ValueMap
lfoCountTo name ipat = innerJoin $ (\i -> pStateF "lfo" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfobus :: Pattern p => p Int -> p Double -> p ValueMap
lfobus busid pat = pF "lfo" pat # pI "^lfo" busid
lforecv :: Pattern p => p Int -> p ValueMap
lforecv busid = pI "^lfo" busid

-- |
lfocutoffint :: Pattern p => p Double -> p ValueMap
lfocutoffint = pF "lfocutoffint"
lfocutoffintTake :: Pattern p => String -> [Double] -> p ValueMap
lfocutoffintTake name xs = pStateListF "lfocutoffint" name xs
lfocutoffintCount :: Pattern p => String -> p ValueMap
lfocutoffintCount name = pStateF "lfocutoffint" name (maybe 0 (+1))
lfocutoffintCountTo :: Pattern p => String -> p Double -> p ValueMap
lfocutoffintCountTo name ipat = innerJoin $ (\i -> pStateF "lfocutoffint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfocutoffintbus :: Pattern p => p Int -> p Double -> p ValueMap
lfocutoffintbus busid pat = pF "lfocutoffint" pat # pI "^lfocutoffint" busid
lfocutoffintrecv :: Pattern p => p Int -> p ValueMap
lfocutoffintrecv busid = pI "^lfocutoffint" busid

-- |
lfodelay :: Pattern p => p Double -> p ValueMap
lfodelay = pF "lfodelay"
lfodelayTake :: Pattern p => String -> [Double] -> p ValueMap
lfodelayTake name xs = pStateListF "lfodelay" name xs
lfodelayCount :: Pattern p => String -> p ValueMap
lfodelayCount name = pStateF "lfodelay" name (maybe 0 (+1))
lfodelayCountTo :: Pattern p => String -> p Double -> p ValueMap
lfodelayCountTo name ipat = innerJoin $ (\i -> pStateF "lfodelay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfodelaybus :: Pattern p => p Int -> p Double -> p ValueMap
lfodelaybus busid pat = pF "lfodelay" pat # pI "^lfodelay" busid
lfodelayrecv :: Pattern p => p Int -> p ValueMap
lfodelayrecv busid = pI "^lfodelay" busid

-- |
lfoint :: Pattern p => p Double -> p ValueMap
lfoint = pF "lfoint"
lfointTake :: Pattern p => String -> [Double] -> p ValueMap
lfointTake name xs = pStateListF "lfoint" name xs
lfointCount :: Pattern p => String -> p ValueMap
lfointCount name = pStateF "lfoint" name (maybe 0 (+1))
lfointCountTo :: Pattern p => String -> p Double -> p ValueMap
lfointCountTo name ipat = innerJoin $ (\i -> pStateF "lfoint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfointbus :: Pattern p => p Int -> p Double -> p ValueMap
lfointbus busid pat = pF "lfoint" pat # pI "^lfoint" busid
lfointrecv :: Pattern p => p Int -> p ValueMap
lfointrecv busid = pI "^lfoint" busid

-- |
lfopitchint :: Pattern p => p Double -> p ValueMap
lfopitchint = pF "lfopitchint"
lfopitchintTake :: Pattern p => String -> [Double] -> p ValueMap
lfopitchintTake name xs = pStateListF "lfopitchint" name xs
lfopitchintCount :: Pattern p => String -> p ValueMap
lfopitchintCount name = pStateF "lfopitchint" name (maybe 0 (+1))
lfopitchintCountTo :: Pattern p => String -> p Double -> p ValueMap
lfopitchintCountTo name ipat = innerJoin $ (\i -> pStateF "lfopitchint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfopitchintbus :: Pattern p => p Int -> p Double -> p ValueMap
lfopitchintbus busid pat = pF "lfopitchint" pat # pI "^lfopitchint" busid
lfopitchintrecv :: Pattern p => p Int -> p ValueMap
lfopitchintrecv busid = pI "^lfopitchint" busid

-- |
lfoshape :: Pattern p => p Double -> p ValueMap
lfoshape = pF "lfoshape"
lfoshapeTake :: Pattern p => String -> [Double] -> p ValueMap
lfoshapeTake name xs = pStateListF "lfoshape" name xs
lfoshapeCount :: Pattern p => String -> p ValueMap
lfoshapeCount name = pStateF "lfoshape" name (maybe 0 (+1))
lfoshapeCountTo :: Pattern p => String -> p Double -> p ValueMap
lfoshapeCountTo name ipat = innerJoin $ (\i -> pStateF "lfoshape" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfoshapebus :: Pattern p => p Int -> p Double -> p ValueMap
lfoshapebus busid pat = pF "lfoshape" pat # pI "^lfoshape" busid
lfoshaperecv :: Pattern p => p Int -> p ValueMap
lfoshaperecv busid = pI "^lfoshape" busid

-- |
lfosync :: Pattern p => p Double -> p ValueMap
lfosync = pF "lfosync"
lfosyncTake :: Pattern p => String -> [Double] -> p ValueMap
lfosyncTake name xs = pStateListF "lfosync" name xs
lfosyncCount :: Pattern p => String -> p ValueMap
lfosyncCount name = pStateF "lfosync" name (maybe 0 (+1))
lfosyncCountTo :: Pattern p => String -> p Double -> p ValueMap
lfosyncCountTo name ipat = innerJoin $ (\i -> pStateF "lfosync" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lfosyncbus :: Pattern p => p Int -> p Double -> p ValueMap
lfosyncbus busid pat = pF "lfosync" pat # pI "^lfosync" busid
lfosyncrecv :: Pattern p => p Int -> p ValueMap
lfosyncrecv busid = pI "^lfosync" busid

-- |
lhitom :: Pattern p => p Double -> p ValueMap
lhitom = pF "lhitom"
lhitomTake :: Pattern p => String -> [Double] -> p ValueMap
lhitomTake name xs = pStateListF "lhitom" name xs
lhitomCount :: Pattern p => String -> p ValueMap
lhitomCount name = pStateF "lhitom" name (maybe 0 (+1))
lhitomCountTo :: Pattern p => String -> p Double -> p ValueMap
lhitomCountTo name ipat = innerJoin $ (\i -> pStateF "lhitom" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lhitombus :: Pattern p => p Int -> p Double -> p ValueMap
lhitombus busid pat = pF "lhitom" pat # pI "^lhitom" busid
lhitomrecv :: Pattern p => p Int -> p ValueMap
lhitomrecv busid = pI "^lhitom" busid

-- |
lkick :: Pattern p => p Double -> p ValueMap
lkick = pF "lkick"
lkickTake :: Pattern p => String -> [Double] -> p ValueMap
lkickTake name xs = pStateListF "lkick" name xs
lkickCount :: Pattern p => String -> p ValueMap
lkickCount name = pStateF "lkick" name (maybe 0 (+1))
lkickCountTo :: Pattern p => String -> p Double -> p ValueMap
lkickCountTo name ipat = innerJoin $ (\i -> pStateF "lkick" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lkickbus :: Pattern p => p Int -> p Double -> p ValueMap
lkickbus busid pat = pF "lkick" pat # pI "^lkick" busid
lkickrecv :: Pattern p => p Int -> p ValueMap
lkickrecv busid = pI "^lkick" busid

-- |
llotom :: Pattern p => p Double -> p ValueMap
llotom = pF "llotom"
llotomTake :: Pattern p => String -> [Double] -> p ValueMap
llotomTake name xs = pStateListF "llotom" name xs
llotomCount :: Pattern p => String -> p ValueMap
llotomCount name = pStateF "llotom" name (maybe 0 (+1))
llotomCountTo :: Pattern p => String -> p Double -> p ValueMap
llotomCountTo name ipat = innerJoin $ (\i -> pStateF "llotom" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

llotombus :: Pattern p => p Int -> p Double -> p ValueMap
llotombus busid pat = pF "llotom" pat # pI "^llotom" busid
llotomrecv :: Pattern p => p Int -> p ValueMap
llotomrecv busid = pI "^llotom" busid

-- | A pattern of numbers. Specifies whether delaytime is calculated relative to cps. When set to 1, delaytime is a direct multiple of a cycle.
lock :: Pattern p => p Double -> p ValueMap
lock = pF "lock"
lockTake :: Pattern p => String -> [Double] -> p ValueMap
lockTake name xs = pStateListF "lock" name xs
lockCount :: Pattern p => String -> p ValueMap
lockCount name = pStateF "lock" name (maybe 0 (+1))
lockCountTo :: Pattern p => String -> p Double -> p ValueMap
lockCountTo name ipat = innerJoin $ (\i -> pStateF "lock" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lockbus :: Pattern p => p Int -> p Double -> p ValueMap
lockbus busid pat = pF "lock" pat # pI "^lock" busid
lockrecv :: Pattern p => p Int -> p ValueMap
lockrecv busid = pI "^lock" busid

-- | loops the sample (from `begin` to `end`) the specified number of times.
loop :: Pattern p => p Double -> p ValueMap
loop = pF "loop"
loopTake :: Pattern p => String -> [Double] -> p ValueMap
loopTake name xs = pStateListF "loop" name xs
loopCount :: Pattern p => String -> p ValueMap
loopCount name = pStateF "loop" name (maybe 0 (+1))
loopCountTo :: Pattern p => String -> p Double -> p ValueMap
loopCountTo name ipat = innerJoin $ (\i -> pStateF "loop" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

loopbus :: Pattern p => p Int -> p Double -> p ValueMap
loopbus _ _ = error "Control parameter 'loop' can't be sent to a bus."

-- |
lophat :: Pattern p => p Double -> p ValueMap
lophat = pF "lophat"
lophatTake :: Pattern p => String -> [Double] -> p ValueMap
lophatTake name xs = pStateListF "lophat" name xs
lophatCount :: Pattern p => String -> p ValueMap
lophatCount name = pStateF "lophat" name (maybe 0 (+1))
lophatCountTo :: Pattern p => String -> p Double -> p ValueMap
lophatCountTo name ipat = innerJoin $ (\i -> pStateF "lophat" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lophatbus :: Pattern p => p Int -> p Double -> p ValueMap
lophatbus busid pat = pF "lophat" pat # pI "^lophat" busid
lophatrecv :: Pattern p => p Int -> p ValueMap
lophatrecv busid = pI "^lophat" busid

-- |
lrate :: Pattern p => p Double -> p ValueMap
lrate = pF "lrate"
lrateTake :: Pattern p => String -> [Double] -> p ValueMap
lrateTake name xs = pStateListF "lrate" name xs
lrateCount :: Pattern p => String -> p ValueMap
lrateCount name = pStateF "lrate" name (maybe 0 (+1))
lrateCountTo :: Pattern p => String -> p Double -> p ValueMap
lrateCountTo name ipat = innerJoin $ (\i -> pStateF "lrate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lratebus :: Pattern p => p Int -> p Double -> p ValueMap
lratebus busid pat = pF "lrate" pat # pI "^lrate" busid
lraterecv :: Pattern p => p Int -> p ValueMap
lraterecv busid = pI "^lrate" busid

-- |
lsize :: Pattern p => p Double -> p ValueMap
lsize = pF "lsize"
lsizeTake :: Pattern p => String -> [Double] -> p ValueMap
lsizeTake name xs = pStateListF "lsize" name xs
lsizeCount :: Pattern p => String -> p ValueMap
lsizeCount name = pStateF "lsize" name (maybe 0 (+1))
lsizeCountTo :: Pattern p => String -> p Double -> p ValueMap
lsizeCountTo name ipat = innerJoin $ (\i -> pStateF "lsize" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lsizebus :: Pattern p => p Int -> p Double -> p ValueMap
lsizebus busid pat = pF "lsize" pat # pI "^lsize" busid
lsizerecv :: Pattern p => p Int -> p ValueMap
lsizerecv busid = pI "^lsize" busid

-- |
lsnare :: Pattern p => p Double -> p ValueMap
lsnare = pF "lsnare"
lsnareTake :: Pattern p => String -> [Double] -> p ValueMap
lsnareTake name xs = pStateListF "lsnare" name xs
lsnareCount :: Pattern p => String -> p ValueMap
lsnareCount name = pStateF "lsnare" name (maybe 0 (+1))
lsnareCountTo :: Pattern p => String -> p Double -> p ValueMap
lsnareCountTo name ipat = innerJoin $ (\i -> pStateF "lsnare" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

lsnarebus :: Pattern p => p Int -> p Double -> p ValueMap
lsnarebus busid pat = pF "lsnare" pat # pI "^lsnare" busid
lsnarerecv :: Pattern p => p Int -> p ValueMap
lsnarerecv busid = pI "^lsnare" busid

-- |
midibend :: Pattern p => p Double -> p ValueMap
midibend = pF "midibend"
midibendTake :: Pattern p => String -> [Double] -> p ValueMap
midibendTake name xs = pStateListF "midibend" name xs
midibendCount :: Pattern p => String -> p ValueMap
midibendCount name = pStateF "midibend" name (maybe 0 (+1))
midibendCountTo :: Pattern p => String -> p Double -> p ValueMap
midibendCountTo name ipat = innerJoin $ (\i -> pStateF "midibend" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

midibendbus :: Pattern p => p Int -> p Double -> p ValueMap
midibendbus _ _ = error "Control parameter 'midibend' can't be sent to a bus."

-- |
midichan :: Pattern p => p Double -> p ValueMap
midichan = pF "midichan"
midichanTake :: Pattern p => String -> [Double] -> p ValueMap
midichanTake name xs = pStateListF "midichan" name xs
midichanCount :: Pattern p => String -> p ValueMap
midichanCount name = pStateF "midichan" name (maybe 0 (+1))
midichanCountTo :: Pattern p => String -> p Double -> p ValueMap
midichanCountTo name ipat = innerJoin $ (\i -> pStateF "midichan" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

midichanbus :: Pattern p => p Int -> p Double -> p ValueMap
midichanbus _ _ = error "Control parameter 'midichan' can't be sent to a bus."

-- |
midicmd :: Pattern p => p String -> p ValueMap
midicmd = pS "midicmd"
midicmdTake :: Pattern p => String -> [Double] -> p ValueMap
midicmdTake name xs = pStateListF "midicmd" name xs
midicmdbus :: Pattern p => p Int -> p String -> p ValueMap
midicmdbus _ _ = error "Control parameter 'midicmd' can't be sent to a bus."

-- |
miditouch :: Pattern p => p Double -> p ValueMap
miditouch = pF "miditouch"
miditouchTake :: Pattern p => String -> [Double] -> p ValueMap
miditouchTake name xs = pStateListF "miditouch" name xs
miditouchCount :: Pattern p => String -> p ValueMap
miditouchCount name = pStateF "miditouch" name (maybe 0 (+1))
miditouchCountTo :: Pattern p => String -> p Double -> p ValueMap
miditouchCountTo name ipat = innerJoin $ (\i -> pStateF "miditouch" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

miditouchbus :: Pattern p => p Int -> p Double -> p ValueMap
miditouchbus _ _ = error "Control parameter 'miditouch' can't be sent to a bus."

-- |
minutes :: Pattern p => p Double -> p ValueMap
minutes = pF "minutes"
minutesTake :: Pattern p => String -> [Double] -> p ValueMap
minutesTake name xs = pStateListF "minutes" name xs
minutesCount :: Pattern p => String -> p ValueMap
minutesCount name = pStateF "minutes" name (maybe 0 (+1))
minutesCountTo :: Pattern p => String -> p Double -> p ValueMap
minutesCountTo name ipat = innerJoin $ (\i -> pStateF "minutes" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

minutesbus :: Pattern p => p Int -> p Double -> p ValueMap
minutesbus _ _ = error "Control parameter 'minutes' can't be sent to a bus."

-- |
modwheel :: Pattern p => p Double -> p ValueMap
modwheel = pF "modwheel"
modwheelTake :: Pattern p => String -> [Double] -> p ValueMap
modwheelTake name xs = pStateListF "modwheel" name xs
modwheelCount :: Pattern p => String -> p ValueMap
modwheelCount name = pStateF "modwheel" name (maybe 0 (+1))
modwheelCountTo :: Pattern p => String -> p Double -> p ValueMap
modwheelCountTo name ipat = innerJoin $ (\i -> pStateF "modwheel" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

modwheelbus :: Pattern p => p Int -> p Double -> p ValueMap
modwheelbus busid pat = pF "modwheel" pat # pI "^modwheel" busid
modwheelrecv :: Pattern p => p Int -> p ValueMap
modwheelrecv busid = pI "^modwheel" busid

-- |
mtranspose :: Pattern p => p Double -> p ValueMap
mtranspose = pF "mtranspose"
mtransposeTake :: Pattern p => String -> [Double] -> p ValueMap
mtransposeTake name xs = pStateListF "mtranspose" name xs
mtransposeCount :: Pattern p => String -> p ValueMap
mtransposeCount name = pStateF "mtranspose" name (maybe 0 (+1))
mtransposeCountTo :: Pattern p => String -> p Double -> p ValueMap
mtransposeCountTo name ipat = innerJoin $ (\i -> pStateF "mtranspose" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

mtransposebus :: Pattern p => p Int -> p Double -> p ValueMap
mtransposebus busid pat = pF "mtranspose" pat # pI "^mtranspose" busid
mtransposerecv :: Pattern p => p Int -> p ValueMap
mtransposerecv busid = pI "^mtranspose" busid

-- | The note or sample number to choose for a synth or sampleset
n :: Pattern p => p Note -> p ValueMap
n = pN "n"
nTake :: Pattern p => String -> [Double] -> p ValueMap
nTake name xs = pStateListF "n" name xs
nCount :: Pattern p => String -> p ValueMap
nCount name = pStateF "n" name (maybe 0 (+1))
nCountTo :: Pattern p => String -> p Double -> p ValueMap
nCountTo name ipat = innerJoin $ (\i -> pStateF "n" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

nbus :: Pattern p => p Int -> p Note -> p ValueMap
nbus _ _ = error "Control parameter 'n' can't be sent to a bus."

-- | The note or pitch to play a sound or synth with
note :: Pattern p => p Note -> p ValueMap
note = pN "note"
noteTake :: Pattern p => String -> [Double] -> p ValueMap
noteTake name xs = pStateListF "note" name xs
noteCount :: Pattern p => String -> p ValueMap
noteCount name = pStateF "note" name (maybe 0 (+1))
noteCountTo :: Pattern p => String -> p Double -> p ValueMap
noteCountTo name ipat = innerJoin $ (\i -> pStateF "note" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

notebus :: Pattern p => p Int -> p Note -> p ValueMap
notebus _ _ = error "Control parameter 'note' can't be sent to a bus."

-- | Nudges events into the future by the specified number of seconds. Negative numbers work up to a point as well (due to internal latency)
nudge :: Pattern p => p Double -> p ValueMap
nudge = pF "nudge"
nudgeTake :: Pattern p => String -> [Double] -> p ValueMap
nudgeTake name xs = pStateListF "nudge" name xs
nudgeCount :: Pattern p => String -> p ValueMap
nudgeCount name = pStateF "nudge" name (maybe 0 (+1))
nudgeCountTo :: Pattern p => String -> p Double -> p ValueMap
nudgeCountTo name ipat = innerJoin $ (\i -> pStateF "nudge" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

nudgebus :: Pattern p => p Int -> p Double -> p ValueMap
nudgebus busid pat = pF "nudge" pat # pI "^nudge" busid
nudgerecv :: Pattern p => p Int -> p ValueMap
nudgerecv busid = pI "^nudge" busid

-- |
octave :: Pattern p => p Int -> p ValueMap
octave = pI "octave"
octaveTake :: Pattern p => String -> [Double] -> p ValueMap
octaveTake name xs = pStateListF "octave" name xs
octaveCount :: Pattern p => String -> p ValueMap
octaveCount name = pStateF "octave" name (maybe 0 (+1))
octaveCountTo :: Pattern p => String -> p Double -> p ValueMap
octaveCountTo name ipat = innerJoin $ (\i -> pStateF "octave" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

octavebus :: Pattern p => p Int -> p Int -> p ValueMap
octavebus _ _ = error "Control parameter 'octave' can't be sent to a bus."

-- |
octaveR :: Pattern p => p Double -> p ValueMap
octaveR = pF "octaveR"
octaveRTake :: Pattern p => String -> [Double] -> p ValueMap
octaveRTake name xs = pStateListF "octaveR" name xs
octaveRCount :: Pattern p => String -> p ValueMap
octaveRCount name = pStateF "octaveR" name (maybe 0 (+1))
octaveRCountTo :: Pattern p => String -> p Double -> p ValueMap
octaveRCountTo name ipat = innerJoin $ (\i -> pStateF "octaveR" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

octaveRbus :: Pattern p => p Int -> p Double -> p ValueMap
octaveRbus busid pat = pF "octaveR" pat # pI "^octaveR" busid
octaveRrecv :: Pattern p => p Int -> p ValueMap
octaveRrecv busid = pI "^octaveR" busid

-- | octaver effect
octer :: Pattern p => p Double -> p ValueMap
octer = pF "octer"
octerTake :: Pattern p => String -> [Double] -> p ValueMap
octerTake name xs = pStateListF "octer" name xs
octerCount :: Pattern p => String -> p ValueMap
octerCount name = pStateF "octer" name (maybe 0 (+1))
octerCountTo :: Pattern p => String -> p Double -> p ValueMap
octerCountTo name ipat = innerJoin $ (\i -> pStateF "octer" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

octerbus :: Pattern p => p Int -> p Double -> p ValueMap
octerbus busid pat = pF "octer" pat # pI "^octer" busid
octerrecv :: Pattern p => p Int -> p ValueMap
octerrecv busid = pI "^octer" busid

-- | octaver effect
octersub :: Pattern p => p Double -> p ValueMap
octersub = pF "octersub"
octersubTake :: Pattern p => String -> [Double] -> p ValueMap
octersubTake name xs = pStateListF "octersub" name xs
octersubCount :: Pattern p => String -> p ValueMap
octersubCount name = pStateF "octersub" name (maybe 0 (+1))
octersubCountTo :: Pattern p => String -> p Double -> p ValueMap
octersubCountTo name ipat = innerJoin $ (\i -> pStateF "octersub" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

octersubbus :: Pattern p => p Int -> p Double -> p ValueMap
octersubbus busid pat = pF "octersub" pat # pI "^octersub" busid
octersubrecv :: Pattern p => p Int -> p ValueMap
octersubrecv busid = pI "^octersub" busid

-- | octaver effect
octersubsub :: Pattern p => p Double -> p ValueMap
octersubsub = pF "octersubsub"
octersubsubTake :: Pattern p => String -> [Double] -> p ValueMap
octersubsubTake name xs = pStateListF "octersubsub" name xs
octersubsubCount :: Pattern p => String -> p ValueMap
octersubsubCount name = pStateF "octersubsub" name (maybe 0 (+1))
octersubsubCountTo :: Pattern p => String -> p Double -> p ValueMap
octersubsubCountTo name ipat = innerJoin $ (\i -> pStateF "octersubsub" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

octersubsubbus :: Pattern p => p Int -> p Double -> p ValueMap
octersubsubbus busid pat = pF "octersubsub" pat # pI "^octersubsub" busid
octersubsubrecv :: Pattern p => p Int -> p ValueMap
octersubsubrecv busid = pI "^octersubsub" busid

-- |
offset :: Pattern p => p Double -> p ValueMap
offset = pF "offset"
offsetTake :: Pattern p => String -> [Double] -> p ValueMap
offsetTake name xs = pStateListF "offset" name xs
offsetCount :: Pattern p => String -> p ValueMap
offsetCount name = pStateF "offset" name (maybe 0 (+1))
offsetCountTo :: Pattern p => String -> p Double -> p ValueMap
offsetCountTo name ipat = innerJoin $ (\i -> pStateF "offset" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

offsetbus :: Pattern p => p Int -> p Double -> p ValueMap
offsetbus _ _ = error "Control parameter 'offset' can't be sent to a bus."

-- |
ophatdecay :: Pattern p => p Double -> p ValueMap
ophatdecay = pF "ophatdecay"
ophatdecayTake :: Pattern p => String -> [Double] -> p ValueMap
ophatdecayTake name xs = pStateListF "ophatdecay" name xs
ophatdecayCount :: Pattern p => String -> p ValueMap
ophatdecayCount name = pStateF "ophatdecay" name (maybe 0 (+1))
ophatdecayCountTo :: Pattern p => String -> p Double -> p ValueMap
ophatdecayCountTo name ipat = innerJoin $ (\i -> pStateF "ophatdecay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ophatdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
ophatdecaybus busid pat = pF "ophatdecay" pat # pI "^ophatdecay" busid
ophatdecayrecv :: Pattern p => p Int -> p ValueMap
ophatdecayrecv busid = pI "^ophatdecay" busid

-- | a pattern of numbers. An `orbit` is a global parameter context for patterns. Patterns with the same orbit will share hardware output bus offset and global effects, e.g. reverb and delay. The maximum number of orbits is specified in the superdirt startup, numbers higher than maximum will wrap around.
orbit :: Pattern p => p Int -> p ValueMap
orbit = pI "orbit"
orbitTake :: Pattern p => String -> [Double] -> p ValueMap
orbitTake name xs = pStateListF "orbit" name xs
orbitCount :: Pattern p => String -> p ValueMap
orbitCount name = pStateF "orbit" name (maybe 0 (+1))
orbitCountTo :: Pattern p => String -> p Double -> p ValueMap
orbitCountTo name ipat = innerJoin $ (\i -> pStateF "orbit" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

orbitbus :: Pattern p => p Int -> p Int -> p ValueMap
orbitbus busid pat = pI "orbit" pat # pI "^orbit" busid
orbitrecv :: Pattern p => p Int -> p ValueMap
orbitrecv busid = pI "^orbit" busid

-- |
overgain :: Pattern p => p Double -> p ValueMap
overgain = pF "overgain"
overgainTake :: Pattern p => String -> [Double] -> p ValueMap
overgainTake name xs = pStateListF "overgain" name xs
overgainCount :: Pattern p => String -> p ValueMap
overgainCount name = pStateF "overgain" name (maybe 0 (+1))
overgainCountTo :: Pattern p => String -> p Double -> p ValueMap
overgainCountTo name ipat = innerJoin $ (\i -> pStateF "overgain" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

overgainbus :: Pattern p => p Int -> p Double -> p ValueMap
overgainbus _ _ = error "Control parameter 'overgain' can't be sent to a bus."

-- |
overshape :: Pattern p => p Double -> p ValueMap
overshape = pF "overshape"
overshapeTake :: Pattern p => String -> [Double] -> p ValueMap
overshapeTake name xs = pStateListF "overshape" name xs
overshapeCount :: Pattern p => String -> p ValueMap
overshapeCount name = pStateF "overshape" name (maybe 0 (+1))
overshapeCountTo :: Pattern p => String -> p Double -> p ValueMap
overshapeCountTo name ipat = innerJoin $ (\i -> pStateF "overshape" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

overshapebus :: Pattern p => p Int -> p Double -> p ValueMap
overshapebus busid pat = pF "overshape" pat # pI "^overshape" busid
overshaperecv :: Pattern p => p Int -> p ValueMap
overshaperecv busid = pI "^overshape" busid

-- | a pattern of numbers between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)
pan :: Pattern p => p Double -> p ValueMap
pan = pF "pan"
panTake :: Pattern p => String -> [Double] -> p ValueMap
panTake name xs = pStateListF "pan" name xs
panCount :: Pattern p => String -> p ValueMap
panCount name = pStateF "pan" name (maybe 0 (+1))
panCountTo :: Pattern p => String -> p Double -> p ValueMap
panCountTo name ipat = innerJoin $ (\i -> pStateF "pan" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

panbus :: Pattern p => p Int -> p Double -> p ValueMap
panbus busid pat = pF "pan" pat # pI "^pan" busid
panrecv :: Pattern p => p Int -> p ValueMap
panrecv busid = pI "^pan" busid

-- | a pattern of numbers between -1.0 and 1.0, which controls the relative position of the centre pan in a pair of adjacent speakers (multichannel only)
panorient :: Pattern p => p Double -> p ValueMap
panorient = pF "panorient"
panorientTake :: Pattern p => String -> [Double] -> p ValueMap
panorientTake name xs = pStateListF "panorient" name xs
panorientCount :: Pattern p => String -> p ValueMap
panorientCount name = pStateF "panorient" name (maybe 0 (+1))
panorientCountTo :: Pattern p => String -> p Double -> p ValueMap
panorientCountTo name ipat = innerJoin $ (\i -> pStateF "panorient" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

panorientbus :: Pattern p => p Int -> p Double -> p ValueMap
panorientbus busid pat = pF "panorient" pat # pI "^panorient" busid
panorientrecv :: Pattern p => p Int -> p ValueMap
panorientrecv busid = pI "^panorient" busid

-- | a pattern of numbers between -inf and inf, which controls how much multichannel output is fanned out (negative is backwards ordering)
panspan :: Pattern p => p Double -> p ValueMap
panspan = pF "panspan"
panspanTake :: Pattern p => String -> [Double] -> p ValueMap
panspanTake name xs = pStateListF "panspan" name xs
panspanCount :: Pattern p => String -> p ValueMap
panspanCount name = pStateF "panspan" name (maybe 0 (+1))
panspanCountTo :: Pattern p => String -> p Double -> p ValueMap
panspanCountTo name ipat = innerJoin $ (\i -> pStateF "panspan" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

panspanbus :: Pattern p => p Int -> p Double -> p ValueMap
panspanbus busid pat = pF "panspan" pat # pI "^panspan" busid
panspanrecv :: Pattern p => p Int -> p ValueMap
panspanrecv busid = pI "^panspan" busid

-- | a pattern of numbers between 0.0 and 1.0, which controls the multichannel spread range (multichannel only)
pansplay :: Pattern p => p Double -> p ValueMap
pansplay = pF "pansplay"
pansplayTake :: Pattern p => String -> [Double] -> p ValueMap
pansplayTake name xs = pStateListF "pansplay" name xs
pansplayCount :: Pattern p => String -> p ValueMap
pansplayCount name = pStateF "pansplay" name (maybe 0 (+1))
pansplayCountTo :: Pattern p => String -> p Double -> p ValueMap
pansplayCountTo name ipat = innerJoin $ (\i -> pStateF "pansplay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

pansplaybus :: Pattern p => p Int -> p Double -> p ValueMap
pansplaybus busid pat = pF "pansplay" pat # pI "^pansplay" busid
pansplayrecv :: Pattern p => p Int -> p ValueMap
pansplayrecv busid = pI "^pansplay" busid

-- | a pattern of numbers between 0.0 and inf, which controls how much each channel is distributed over neighbours (multichannel only)
panwidth :: Pattern p => p Double -> p ValueMap
panwidth = pF "panwidth"
panwidthTake :: Pattern p => String -> [Double] -> p ValueMap
panwidthTake name xs = pStateListF "panwidth" name xs
panwidthCount :: Pattern p => String -> p ValueMap
panwidthCount name = pStateF "panwidth" name (maybe 0 (+1))
panwidthCountTo :: Pattern p => String -> p Double -> p ValueMap
panwidthCountTo name ipat = innerJoin $ (\i -> pStateF "panwidth" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

panwidthbus :: Pattern p => p Int -> p Double -> p ValueMap
panwidthbus busid pat = pF "panwidth" pat # pI "^panwidth" busid
panwidthrecv :: Pattern p => p Int -> p ValueMap
panwidthrecv busid = pI "^panwidth" busid

-- |
partials :: Pattern p => p Double -> p ValueMap
partials = pF "partials"
partialsTake :: Pattern p => String -> [Double] -> p ValueMap
partialsTake name xs = pStateListF "partials" name xs
partialsCount :: Pattern p => String -> p ValueMap
partialsCount name = pStateF "partials" name (maybe 0 (+1))
partialsCountTo :: Pattern p => String -> p Double -> p ValueMap
partialsCountTo name ipat = innerJoin $ (\i -> pStateF "partials" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

partialsbus :: Pattern p => p Int -> p Double -> p ValueMap
partialsbus busid pat = pF "partials" pat # pI "^partials" busid
partialsrecv :: Pattern p => p Int -> p ValueMap
partialsrecv busid = pI "^partials" busid

-- | Phaser Audio DSP effect | params are 'phaserrate' and 'phaserdepth'
phaserdepth :: Pattern p => p Double -> p ValueMap
phaserdepth = pF "phaserdepth"
phaserdepthTake :: Pattern p => String -> [Double] -> p ValueMap
phaserdepthTake name xs = pStateListF "phaserdepth" name xs
phaserdepthCount :: Pattern p => String -> p ValueMap
phaserdepthCount name = pStateF "phaserdepth" name (maybe 0 (+1))
phaserdepthCountTo :: Pattern p => String -> p Double -> p ValueMap
phaserdepthCountTo name ipat = innerJoin $ (\i -> pStateF "phaserdepth" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

phaserdepthbus :: Pattern p => p Int -> p Double -> p ValueMap
phaserdepthbus busid pat = pF "phaserdepth" pat # pI "^phaserdepth" busid
phaserdepthrecv :: Pattern p => p Int -> p ValueMap
phaserdepthrecv busid = pI "^phaserdepth" busid

-- | Phaser Audio DSP effect | params are 'phaserrate' and 'phaserdepth'
phaserrate :: Pattern p => p Double -> p ValueMap
phaserrate = pF "phaserrate"
phaserrateTake :: Pattern p => String -> [Double] -> p ValueMap
phaserrateTake name xs = pStateListF "phaserrate" name xs
phaserrateCount :: Pattern p => String -> p ValueMap
phaserrateCount name = pStateF "phaserrate" name (maybe 0 (+1))
phaserrateCountTo :: Pattern p => String -> p Double -> p ValueMap
phaserrateCountTo name ipat = innerJoin $ (\i -> pStateF "phaserrate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

phaserratebus :: Pattern p => p Int -> p Double -> p ValueMap
phaserratebus busid pat = pF "phaserrate" pat # pI "^phaserrate" busid
phaserraterecv :: Pattern p => p Int -> p ValueMap
phaserraterecv busid = pI "^phaserrate" busid

-- |
pitch1 :: Pattern p => p Double -> p ValueMap
pitch1 = pF "pitch1"
pitch1Take :: Pattern p => String -> [Double] -> p ValueMap
pitch1Take name xs = pStateListF "pitch1" name xs
pitch1Count :: Pattern p => String -> p ValueMap
pitch1Count name = pStateF "pitch1" name (maybe 0 (+1))
pitch1CountTo :: Pattern p => String -> p Double -> p ValueMap
pitch1CountTo name ipat = innerJoin $ (\i -> pStateF "pitch1" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

pitch1bus :: Pattern p => p Int -> p Double -> p ValueMap
pitch1bus busid pat = pF "pitch1" pat # pI "^pitch1" busid
pitch1recv :: Pattern p => p Int -> p ValueMap
pitch1recv busid = pI "^pitch1" busid

-- |
pitch2 :: Pattern p => p Double -> p ValueMap
pitch2 = pF "pitch2"
pitch2Take :: Pattern p => String -> [Double] -> p ValueMap
pitch2Take name xs = pStateListF "pitch2" name xs
pitch2Count :: Pattern p => String -> p ValueMap
pitch2Count name = pStateF "pitch2" name (maybe 0 (+1))
pitch2CountTo :: Pattern p => String -> p Double -> p ValueMap
pitch2CountTo name ipat = innerJoin $ (\i -> pStateF "pitch2" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

pitch2bus :: Pattern p => p Int -> p Double -> p ValueMap
pitch2bus busid pat = pF "pitch2" pat # pI "^pitch2" busid
pitch2recv :: Pattern p => p Int -> p ValueMap
pitch2recv busid = pI "^pitch2" busid

-- |
pitch3 :: Pattern p => p Double -> p ValueMap
pitch3 = pF "pitch3"
pitch3Take :: Pattern p => String -> [Double] -> p ValueMap
pitch3Take name xs = pStateListF "pitch3" name xs
pitch3Count :: Pattern p => String -> p ValueMap
pitch3Count name = pStateF "pitch3" name (maybe 0 (+1))
pitch3CountTo :: Pattern p => String -> p Double -> p ValueMap
pitch3CountTo name ipat = innerJoin $ (\i -> pStateF "pitch3" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

pitch3bus :: Pattern p => p Int -> p Double -> p ValueMap
pitch3bus busid pat = pF "pitch3" pat # pI "^pitch3" busid
pitch3recv :: Pattern p => p Int -> p ValueMap
pitch3recv busid = pI "^pitch3" busid

-- |
polyTouch :: Pattern p => p Double -> p ValueMap
polyTouch = pF "polyTouch"
polyTouchTake :: Pattern p => String -> [Double] -> p ValueMap
polyTouchTake name xs = pStateListF "polyTouch" name xs
polyTouchCount :: Pattern p => String -> p ValueMap
polyTouchCount name = pStateF "polyTouch" name (maybe 0 (+1))
polyTouchCountTo :: Pattern p => String -> p Double -> p ValueMap
polyTouchCountTo name ipat = innerJoin $ (\i -> pStateF "polyTouch" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

polyTouchbus :: Pattern p => p Int -> p Double -> p ValueMap
polyTouchbus _ _ = error "Control parameter 'polyTouch' can't be sent to a bus."

-- |
portamento :: Pattern p => p Double -> p ValueMap
portamento = pF "portamento"
portamentoTake :: Pattern p => String -> [Double] -> p ValueMap
portamentoTake name xs = pStateListF "portamento" name xs
portamentoCount :: Pattern p => String -> p ValueMap
portamentoCount name = pStateF "portamento" name (maybe 0 (+1))
portamentoCountTo :: Pattern p => String -> p Double -> p ValueMap
portamentoCountTo name ipat = innerJoin $ (\i -> pStateF "portamento" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

portamentobus :: Pattern p => p Int -> p Double -> p ValueMap
portamentobus busid pat = pF "portamento" pat # pI "^portamento" busid
portamentorecv :: Pattern p => p Int -> p ValueMap
portamentorecv busid = pI "^portamento" busid

-- |
progNum :: Pattern p => p Double -> p ValueMap
progNum = pF "progNum"
progNumTake :: Pattern p => String -> [Double] -> p ValueMap
progNumTake name xs = pStateListF "progNum" name xs
progNumCount :: Pattern p => String -> p ValueMap
progNumCount name = pStateF "progNum" name (maybe 0 (+1))
progNumCountTo :: Pattern p => String -> p Double -> p ValueMap
progNumCountTo name ipat = innerJoin $ (\i -> pStateF "progNum" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

progNumbus :: Pattern p => p Int -> p Double -> p ValueMap
progNumbus _ _ = error "Control parameter 'progNum' can't be sent to a bus."

-- | used in SuperDirt softsynths as a control rate or 'speed'
rate :: Pattern p => p Double -> p ValueMap
rate = pF "rate"
rateTake :: Pattern p => String -> [Double] -> p ValueMap
rateTake name xs = pStateListF "rate" name xs
rateCount :: Pattern p => String -> p ValueMap
rateCount name = pStateF "rate" name (maybe 0 (+1))
rateCountTo :: Pattern p => String -> p Double -> p ValueMap
rateCountTo name ipat = innerJoin $ (\i -> pStateF "rate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ratebus :: Pattern p => p Int -> p Double -> p ValueMap
ratebus busid pat = pF "rate" pat # pI "^rate" busid
raterecv :: Pattern p => p Int -> p ValueMap
raterecv busid = pI "^rate" busid

-- | Spectral conform
real :: Pattern p => p Double -> p ValueMap
real = pF "real"
realTake :: Pattern p => String -> [Double] -> p ValueMap
realTake name xs = pStateListF "real" name xs
realCount :: Pattern p => String -> p ValueMap
realCount name = pStateF "real" name (maybe 0 (+1))
realCountTo :: Pattern p => String -> p Double -> p ValueMap
realCountTo name ipat = innerJoin $ (\i -> pStateF "real" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

realbus :: Pattern p => p Int -> p Double -> p ValueMap
realbus busid pat = pF "real" pat # pI "^real" busid
realrecv :: Pattern p => p Int -> p ValueMap
realrecv busid = pI "^real" busid

-- | a pattern of numbers to specify the release time (in seconds) of an envelope applied to each sample.
release :: Pattern p => p Double -> p ValueMap
release = pF "release"
releaseTake :: Pattern p => String -> [Double] -> p ValueMap
releaseTake name xs = pStateListF "release" name xs
releaseCount :: Pattern p => String -> p ValueMap
releaseCount name = pStateF "release" name (maybe 0 (+1))
releaseCountTo :: Pattern p => String -> p Double -> p ValueMap
releaseCountTo name ipat = innerJoin $ (\i -> pStateF "release" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

releasebus :: Pattern p => p Int -> p Double -> p ValueMap
releasebus busid pat = pF "release" pat # pI "^release" busid
releaserecv :: Pattern p => p Int -> p ValueMap
releaserecv busid = pI "^release" busid

-- | a pattern of numbers from 0 to 1. Specifies the resonance of the low-pass filter.
resonance :: Pattern p => p Double -> p ValueMap
resonance = pF "resonance"
resonanceTake :: Pattern p => String -> [Double] -> p ValueMap
resonanceTake name xs = pStateListF "resonance" name xs
resonanceCount :: Pattern p => String -> p ValueMap
resonanceCount name = pStateF "resonance" name (maybe 0 (+1))
resonanceCountTo :: Pattern p => String -> p Double -> p ValueMap
resonanceCountTo name ipat = innerJoin $ (\i -> pStateF "resonance" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

resonancebus :: Pattern p => p Int -> p Double -> p ValueMap
resonancebus busid pat = pF "resonance" pat # pI "^resonance" busid
resonancerecv :: Pattern p => p Int -> p ValueMap
resonancerecv busid = pI "^resonance" busid

-- | ring modulation
ring :: Pattern p => p Double -> p ValueMap
ring = pF "ring"
ringTake :: Pattern p => String -> [Double] -> p ValueMap
ringTake name xs = pStateListF "ring" name xs
ringCount :: Pattern p => String -> p ValueMap
ringCount name = pStateF "ring" name (maybe 0 (+1))
ringCountTo :: Pattern p => String -> p Double -> p ValueMap
ringCountTo name ipat = innerJoin $ (\i -> pStateF "ring" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ringbus :: Pattern p => p Int -> p Double -> p ValueMap
ringbus busid pat = pF "ring" pat # pI "^ring" busid
ringrecv :: Pattern p => p Int -> p ValueMap
ringrecv busid = pI "^ring" busid

-- | ring modulation
ringdf :: Pattern p => p Double -> p ValueMap
ringdf = pF "ringdf"
ringdfTake :: Pattern p => String -> [Double] -> p ValueMap
ringdfTake name xs = pStateListF "ringdf" name xs
ringdfCount :: Pattern p => String -> p ValueMap
ringdfCount name = pStateF "ringdf" name (maybe 0 (+1))
ringdfCountTo :: Pattern p => String -> p Double -> p ValueMap
ringdfCountTo name ipat = innerJoin $ (\i -> pStateF "ringdf" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ringdfbus :: Pattern p => p Int -> p Double -> p ValueMap
ringdfbus busid pat = pF "ringdf" pat # pI "^ringdf" busid
ringdfrecv :: Pattern p => p Int -> p ValueMap
ringdfrecv busid = pI "^ringdf" busid

-- | ring modulation
ringf :: Pattern p => p Double -> p ValueMap
ringf = pF "ringf"
ringfTake :: Pattern p => String -> [Double] -> p ValueMap
ringfTake name xs = pStateListF "ringf" name xs
ringfCount :: Pattern p => String -> p ValueMap
ringfCount name = pStateF "ringf" name (maybe 0 (+1))
ringfCountTo :: Pattern p => String -> p Double -> p ValueMap
ringfCountTo name ipat = innerJoin $ (\i -> pStateF "ringf" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

ringfbus :: Pattern p => p Int -> p Double -> p ValueMap
ringfbus busid pat = pF "ringf" pat # pI "^ringf" busid
ringfrecv :: Pattern p => p Int -> p ValueMap
ringfrecv busid = pI "^ringf" busid

-- | a pattern of numbers from 0 to 1. Sets the level of reverb.
room :: Pattern p => p Double -> p ValueMap
room = pF "room"
roomTake :: Pattern p => String -> [Double] -> p ValueMap
roomTake name xs = pStateListF "room" name xs
roomCount :: Pattern p => String -> p ValueMap
roomCount name = pStateF "room" name (maybe 0 (+1))
roomCountTo :: Pattern p => String -> p Double -> p ValueMap
roomCountTo name ipat = innerJoin $ (\i -> pStateF "room" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

roombus :: Pattern p => p Int -> p Double -> p ValueMap
roombus busid pat = pF "room" pat # pI "^room" busid
roomrecv :: Pattern p => p Int -> p ValueMap
roomrecv busid = pI "^room" busid

-- |
sagogo :: Pattern p => p Double -> p ValueMap
sagogo = pF "sagogo"
sagogoTake :: Pattern p => String -> [Double] -> p ValueMap
sagogoTake name xs = pStateListF "sagogo" name xs
sagogoCount :: Pattern p => String -> p ValueMap
sagogoCount name = pStateF "sagogo" name (maybe 0 (+1))
sagogoCountTo :: Pattern p => String -> p Double -> p ValueMap
sagogoCountTo name ipat = innerJoin $ (\i -> pStateF "sagogo" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sagogobus :: Pattern p => p Int -> p Double -> p ValueMap
sagogobus busid pat = pF "sagogo" pat # pI "^sagogo" busid
sagogorecv :: Pattern p => p Int -> p ValueMap
sagogorecv busid = pI "^sagogo" busid

-- |
sclap :: Pattern p => p Double -> p ValueMap
sclap = pF "sclap"
sclapTake :: Pattern p => String -> [Double] -> p ValueMap
sclapTake name xs = pStateListF "sclap" name xs
sclapCount :: Pattern p => String -> p ValueMap
sclapCount name = pStateF "sclap" name (maybe 0 (+1))
sclapCountTo :: Pattern p => String -> p Double -> p ValueMap
sclapCountTo name ipat = innerJoin $ (\i -> pStateF "sclap" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sclapbus :: Pattern p => p Int -> p Double -> p ValueMap
sclapbus busid pat = pF "sclap" pat # pI "^sclap" busid
sclaprecv :: Pattern p => p Int -> p ValueMap
sclaprecv busid = pI "^sclap" busid

-- |
sclaves :: Pattern p => p Double -> p ValueMap
sclaves = pF "sclaves"
sclavesTake :: Pattern p => String -> [Double] -> p ValueMap
sclavesTake name xs = pStateListF "sclaves" name xs
sclavesCount :: Pattern p => String -> p ValueMap
sclavesCount name = pStateF "sclaves" name (maybe 0 (+1))
sclavesCountTo :: Pattern p => String -> p Double -> p ValueMap
sclavesCountTo name ipat = innerJoin $ (\i -> pStateF "sclaves" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sclavesbus :: Pattern p => p Int -> p Double -> p ValueMap
sclavesbus busid pat = pF "sclaves" pat # pI "^sclaves" busid
sclavesrecv :: Pattern p => p Int -> p ValueMap
sclavesrecv busid = pI "^sclaves" busid

-- | Spectral scramble
scram :: Pattern p => p Double -> p ValueMap
scram = pF "scram"
scramTake :: Pattern p => String -> [Double] -> p ValueMap
scramTake name xs = pStateListF "scram" name xs
scramCount :: Pattern p => String -> p ValueMap
scramCount name = pStateF "scram" name (maybe 0 (+1))
scramCountTo :: Pattern p => String -> p Double -> p ValueMap
scramCountTo name ipat = innerJoin $ (\i -> pStateF "scram" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

scrambus :: Pattern p => p Int -> p Double -> p ValueMap
scrambus busid pat = pF "scram" pat # pI "^scram" busid
scramrecv :: Pattern p => p Int -> p ValueMap
scramrecv busid = pI "^scram" busid

-- |
scrash :: Pattern p => p Double -> p ValueMap
scrash = pF "scrash"
scrashTake :: Pattern p => String -> [Double] -> p ValueMap
scrashTake name xs = pStateListF "scrash" name xs
scrashCount :: Pattern p => String -> p ValueMap
scrashCount name = pStateF "scrash" name (maybe 0 (+1))
scrashCountTo :: Pattern p => String -> p Double -> p ValueMap
scrashCountTo name ipat = innerJoin $ (\i -> pStateF "scrash" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

scrashbus :: Pattern p => p Int -> p Double -> p ValueMap
scrashbus busid pat = pF "scrash" pat # pI "^scrash" busid
scrashrecv :: Pattern p => p Int -> p ValueMap
scrashrecv busid = pI "^scrash" busid

-- |
seconds :: Pattern p => p Double -> p ValueMap
seconds = pF "seconds"
secondsTake :: Pattern p => String -> [Double] -> p ValueMap
secondsTake name xs = pStateListF "seconds" name xs
secondsCount :: Pattern p => String -> p ValueMap
secondsCount name = pStateF "seconds" name (maybe 0 (+1))
secondsCountTo :: Pattern p => String -> p Double -> p ValueMap
secondsCountTo name ipat = innerJoin $ (\i -> pStateF "seconds" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

secondsbus :: Pattern p => p Int -> p Double -> p ValueMap
secondsbus _ _ = error "Control parameter 'seconds' can't be sent to a bus."

-- |
semitone :: Pattern p => p Double -> p ValueMap
semitone = pF "semitone"
semitoneTake :: Pattern p => String -> [Double] -> p ValueMap
semitoneTake name xs = pStateListF "semitone" name xs
semitoneCount :: Pattern p => String -> p ValueMap
semitoneCount name = pStateF "semitone" name (maybe 0 (+1))
semitoneCountTo :: Pattern p => String -> p Double -> p ValueMap
semitoneCountTo name ipat = innerJoin $ (\i -> pStateF "semitone" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

semitonebus :: Pattern p => p Int -> p Double -> p ValueMap
semitonebus busid pat = pF "semitone" pat # pI "^semitone" busid
semitonerecv :: Pattern p => p Int -> p ValueMap
semitonerecv busid = pI "^semitone" busid

-- | wave shaping distortion, a pattern of numbers from 0 for no distortion up to 1 for loads of distortion.
shape :: Pattern p => p Double -> p ValueMap
shape = pF "shape"
shapeTake :: Pattern p => String -> [Double] -> p ValueMap
shapeTake name xs = pStateListF "shape" name xs
shapeCount :: Pattern p => String -> p ValueMap
shapeCount name = pStateF "shape" name (maybe 0 (+1))
shapeCountTo :: Pattern p => String -> p Double -> p ValueMap
shapeCountTo name ipat = innerJoin $ (\i -> pStateF "shape" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

shapebus :: Pattern p => p Int -> p Double -> p ValueMap
shapebus busid pat = pF "shape" pat # pI "^shape" busid
shaperecv :: Pattern p => p Int -> p ValueMap
shaperecv busid = pI "^shape" busid

-- | a pattern of numbers from 0 to 1. Sets the perceptual size (reverb time) of the `room` to be used in reverb.
size :: Pattern p => p Double -> p ValueMap
size = pF "size"
sizeTake :: Pattern p => String -> [Double] -> p ValueMap
sizeTake name xs = pStateListF "size" name xs
sizeCount :: Pattern p => String -> p ValueMap
sizeCount name = pStateF "size" name (maybe 0 (+1))
sizeCountTo :: Pattern p => String -> p Double -> p ValueMap
sizeCountTo name ipat = innerJoin $ (\i -> pStateF "size" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sizebus :: Pattern p => p Int -> p Double -> p ValueMap
sizebus busid pat = pF "size" pat # pI "^size" busid
sizerecv :: Pattern p => p Int -> p ValueMap
sizerecv busid = pI "^size" busid

-- |
slide :: Pattern p => p Double -> p ValueMap
slide = pF "slide"
slideTake :: Pattern p => String -> [Double] -> p ValueMap
slideTake name xs = pStateListF "slide" name xs
slideCount :: Pattern p => String -> p ValueMap
slideCount name = pStateF "slide" name (maybe 0 (+1))
slideCountTo :: Pattern p => String -> p Double -> p ValueMap
slideCountTo name ipat = innerJoin $ (\i -> pStateF "slide" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slidebus :: Pattern p => p Int -> p Double -> p ValueMap
slidebus busid pat = pF "slide" pat # pI "^slide" busid
sliderecv :: Pattern p => p Int -> p ValueMap
sliderecv busid = pI "^slide" busid

-- |
slider0 :: Pattern p => p Double -> p ValueMap
slider0 = pF "slider0"
slider0Take :: Pattern p => String -> [Double] -> p ValueMap
slider0Take name xs = pStateListF "slider0" name xs
slider0Count :: Pattern p => String -> p ValueMap
slider0Count name = pStateF "slider0" name (maybe 0 (+1))
slider0CountTo :: Pattern p => String -> p Double -> p ValueMap
slider0CountTo name ipat = innerJoin $ (\i -> pStateF "slider0" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider0bus :: Pattern p => p Int -> p Double -> p ValueMap
slider0bus busid pat = pF "slider0" pat # pI "^slider0" busid
slider0recv :: Pattern p => p Int -> p ValueMap
slider0recv busid = pI "^slider0" busid

-- |
slider1 :: Pattern p => p Double -> p ValueMap
slider1 = pF "slider1"
slider1Take :: Pattern p => String -> [Double] -> p ValueMap
slider1Take name xs = pStateListF "slider1" name xs
slider1Count :: Pattern p => String -> p ValueMap
slider1Count name = pStateF "slider1" name (maybe 0 (+1))
slider1CountTo :: Pattern p => String -> p Double -> p ValueMap
slider1CountTo name ipat = innerJoin $ (\i -> pStateF "slider1" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider1bus :: Pattern p => p Int -> p Double -> p ValueMap
slider1bus busid pat = pF "slider1" pat # pI "^slider1" busid
slider1recv :: Pattern p => p Int -> p ValueMap
slider1recv busid = pI "^slider1" busid

-- |
slider10 :: Pattern p => p Double -> p ValueMap
slider10 = pF "slider10"
slider10Take :: Pattern p => String -> [Double] -> p ValueMap
slider10Take name xs = pStateListF "slider10" name xs
slider10Count :: Pattern p => String -> p ValueMap
slider10Count name = pStateF "slider10" name (maybe 0 (+1))
slider10CountTo :: Pattern p => String -> p Double -> p ValueMap
slider10CountTo name ipat = innerJoin $ (\i -> pStateF "slider10" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider10bus :: Pattern p => p Int -> p Double -> p ValueMap
slider10bus busid pat = pF "slider10" pat # pI "^slider10" busid
slider10recv :: Pattern p => p Int -> p ValueMap
slider10recv busid = pI "^slider10" busid

-- |
slider11 :: Pattern p => p Double -> p ValueMap
slider11 = pF "slider11"
slider11Take :: Pattern p => String -> [Double] -> p ValueMap
slider11Take name xs = pStateListF "slider11" name xs
slider11Count :: Pattern p => String -> p ValueMap
slider11Count name = pStateF "slider11" name (maybe 0 (+1))
slider11CountTo :: Pattern p => String -> p Double -> p ValueMap
slider11CountTo name ipat = innerJoin $ (\i -> pStateF "slider11" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider11bus :: Pattern p => p Int -> p Double -> p ValueMap
slider11bus busid pat = pF "slider11" pat # pI "^slider11" busid
slider11recv :: Pattern p => p Int -> p ValueMap
slider11recv busid = pI "^slider11" busid

-- |
slider12 :: Pattern p => p Double -> p ValueMap
slider12 = pF "slider12"
slider12Take :: Pattern p => String -> [Double] -> p ValueMap
slider12Take name xs = pStateListF "slider12" name xs
slider12Count :: Pattern p => String -> p ValueMap
slider12Count name = pStateF "slider12" name (maybe 0 (+1))
slider12CountTo :: Pattern p => String -> p Double -> p ValueMap
slider12CountTo name ipat = innerJoin $ (\i -> pStateF "slider12" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider12bus :: Pattern p => p Int -> p Double -> p ValueMap
slider12bus busid pat = pF "slider12" pat # pI "^slider12" busid
slider12recv :: Pattern p => p Int -> p ValueMap
slider12recv busid = pI "^slider12" busid

-- |
slider13 :: Pattern p => p Double -> p ValueMap
slider13 = pF "slider13"
slider13Take :: Pattern p => String -> [Double] -> p ValueMap
slider13Take name xs = pStateListF "slider13" name xs
slider13Count :: Pattern p => String -> p ValueMap
slider13Count name = pStateF "slider13" name (maybe 0 (+1))
slider13CountTo :: Pattern p => String -> p Double -> p ValueMap
slider13CountTo name ipat = innerJoin $ (\i -> pStateF "slider13" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider13bus :: Pattern p => p Int -> p Double -> p ValueMap
slider13bus busid pat = pF "slider13" pat # pI "^slider13" busid
slider13recv :: Pattern p => p Int -> p ValueMap
slider13recv busid = pI "^slider13" busid

-- |
slider14 :: Pattern p => p Double -> p ValueMap
slider14 = pF "slider14"
slider14Take :: Pattern p => String -> [Double] -> p ValueMap
slider14Take name xs = pStateListF "slider14" name xs
slider14Count :: Pattern p => String -> p ValueMap
slider14Count name = pStateF "slider14" name (maybe 0 (+1))
slider14CountTo :: Pattern p => String -> p Double -> p ValueMap
slider14CountTo name ipat = innerJoin $ (\i -> pStateF "slider14" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider14bus :: Pattern p => p Int -> p Double -> p ValueMap
slider14bus busid pat = pF "slider14" pat # pI "^slider14" busid
slider14recv :: Pattern p => p Int -> p ValueMap
slider14recv busid = pI "^slider14" busid

-- |
slider15 :: Pattern p => p Double -> p ValueMap
slider15 = pF "slider15"
slider15Take :: Pattern p => String -> [Double] -> p ValueMap
slider15Take name xs = pStateListF "slider15" name xs
slider15Count :: Pattern p => String -> p ValueMap
slider15Count name = pStateF "slider15" name (maybe 0 (+1))
slider15CountTo :: Pattern p => String -> p Double -> p ValueMap
slider15CountTo name ipat = innerJoin $ (\i -> pStateF "slider15" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider15bus :: Pattern p => p Int -> p Double -> p ValueMap
slider15bus busid pat = pF "slider15" pat # pI "^slider15" busid
slider15recv :: Pattern p => p Int -> p ValueMap
slider15recv busid = pI "^slider15" busid

-- |
slider2 :: Pattern p => p Double -> p ValueMap
slider2 = pF "slider2"
slider2Take :: Pattern p => String -> [Double] -> p ValueMap
slider2Take name xs = pStateListF "slider2" name xs
slider2Count :: Pattern p => String -> p ValueMap
slider2Count name = pStateF "slider2" name (maybe 0 (+1))
slider2CountTo :: Pattern p => String -> p Double -> p ValueMap
slider2CountTo name ipat = innerJoin $ (\i -> pStateF "slider2" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider2bus :: Pattern p => p Int -> p Double -> p ValueMap
slider2bus busid pat = pF "slider2" pat # pI "^slider2" busid
slider2recv :: Pattern p => p Int -> p ValueMap
slider2recv busid = pI "^slider2" busid

-- |
slider3 :: Pattern p => p Double -> p ValueMap
slider3 = pF "slider3"
slider3Take :: Pattern p => String -> [Double] -> p ValueMap
slider3Take name xs = pStateListF "slider3" name xs
slider3Count :: Pattern p => String -> p ValueMap
slider3Count name = pStateF "slider3" name (maybe 0 (+1))
slider3CountTo :: Pattern p => String -> p Double -> p ValueMap
slider3CountTo name ipat = innerJoin $ (\i -> pStateF "slider3" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider3bus :: Pattern p => p Int -> p Double -> p ValueMap
slider3bus busid pat = pF "slider3" pat # pI "^slider3" busid
slider3recv :: Pattern p => p Int -> p ValueMap
slider3recv busid = pI "^slider3" busid

-- |
slider4 :: Pattern p => p Double -> p ValueMap
slider4 = pF "slider4"
slider4Take :: Pattern p => String -> [Double] -> p ValueMap
slider4Take name xs = pStateListF "slider4" name xs
slider4Count :: Pattern p => String -> p ValueMap
slider4Count name = pStateF "slider4" name (maybe 0 (+1))
slider4CountTo :: Pattern p => String -> p Double -> p ValueMap
slider4CountTo name ipat = innerJoin $ (\i -> pStateF "slider4" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider4bus :: Pattern p => p Int -> p Double -> p ValueMap
slider4bus busid pat = pF "slider4" pat # pI "^slider4" busid
slider4recv :: Pattern p => p Int -> p ValueMap
slider4recv busid = pI "^slider4" busid

-- |
slider5 :: Pattern p => p Double -> p ValueMap
slider5 = pF "slider5"
slider5Take :: Pattern p => String -> [Double] -> p ValueMap
slider5Take name xs = pStateListF "slider5" name xs
slider5Count :: Pattern p => String -> p ValueMap
slider5Count name = pStateF "slider5" name (maybe 0 (+1))
slider5CountTo :: Pattern p => String -> p Double -> p ValueMap
slider5CountTo name ipat = innerJoin $ (\i -> pStateF "slider5" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider5bus :: Pattern p => p Int -> p Double -> p ValueMap
slider5bus busid pat = pF "slider5" pat # pI "^slider5" busid
slider5recv :: Pattern p => p Int -> p ValueMap
slider5recv busid = pI "^slider5" busid

-- |
slider6 :: Pattern p => p Double -> p ValueMap
slider6 = pF "slider6"
slider6Take :: Pattern p => String -> [Double] -> p ValueMap
slider6Take name xs = pStateListF "slider6" name xs
slider6Count :: Pattern p => String -> p ValueMap
slider6Count name = pStateF "slider6" name (maybe 0 (+1))
slider6CountTo :: Pattern p => String -> p Double -> p ValueMap
slider6CountTo name ipat = innerJoin $ (\i -> pStateF "slider6" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider6bus :: Pattern p => p Int -> p Double -> p ValueMap
slider6bus busid pat = pF "slider6" pat # pI "^slider6" busid
slider6recv :: Pattern p => p Int -> p ValueMap
slider6recv busid = pI "^slider6" busid

-- |
slider7 :: Pattern p => p Double -> p ValueMap
slider7 = pF "slider7"
slider7Take :: Pattern p => String -> [Double] -> p ValueMap
slider7Take name xs = pStateListF "slider7" name xs
slider7Count :: Pattern p => String -> p ValueMap
slider7Count name = pStateF "slider7" name (maybe 0 (+1))
slider7CountTo :: Pattern p => String -> p Double -> p ValueMap
slider7CountTo name ipat = innerJoin $ (\i -> pStateF "slider7" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider7bus :: Pattern p => p Int -> p Double -> p ValueMap
slider7bus busid pat = pF "slider7" pat # pI "^slider7" busid
slider7recv :: Pattern p => p Int -> p ValueMap
slider7recv busid = pI "^slider7" busid

-- |
slider8 :: Pattern p => p Double -> p ValueMap
slider8 = pF "slider8"
slider8Take :: Pattern p => String -> [Double] -> p ValueMap
slider8Take name xs = pStateListF "slider8" name xs
slider8Count :: Pattern p => String -> p ValueMap
slider8Count name = pStateF "slider8" name (maybe 0 (+1))
slider8CountTo :: Pattern p => String -> p Double -> p ValueMap
slider8CountTo name ipat = innerJoin $ (\i -> pStateF "slider8" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider8bus :: Pattern p => p Int -> p Double -> p ValueMap
slider8bus busid pat = pF "slider8" pat # pI "^slider8" busid
slider8recv :: Pattern p => p Int -> p ValueMap
slider8recv busid = pI "^slider8" busid

-- |
slider9 :: Pattern p => p Double -> p ValueMap
slider9 = pF "slider9"
slider9Take :: Pattern p => String -> [Double] -> p ValueMap
slider9Take name xs = pStateListF "slider9" name xs
slider9Count :: Pattern p => String -> p ValueMap
slider9Count name = pStateF "slider9" name (maybe 0 (+1))
slider9CountTo :: Pattern p => String -> p Double -> p ValueMap
slider9CountTo name ipat = innerJoin $ (\i -> pStateF "slider9" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

slider9bus :: Pattern p => p Int -> p Double -> p ValueMap
slider9bus busid pat = pF "slider9" pat # pI "^slider9" busid
slider9recv :: Pattern p => p Int -> p ValueMap
slider9recv busid = pI "^slider9" busid

-- | Spectral smear
smear :: Pattern p => p Double -> p ValueMap
smear = pF "smear"
smearTake :: Pattern p => String -> [Double] -> p ValueMap
smearTake name xs = pStateListF "smear" name xs
smearCount :: Pattern p => String -> p ValueMap
smearCount name = pStateF "smear" name (maybe 0 (+1))
smearCountTo :: Pattern p => String -> p Double -> p ValueMap
smearCountTo name ipat = innerJoin $ (\i -> pStateF "smear" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

smearbus :: Pattern p => p Int -> p Double -> p ValueMap
smearbus busid pat = pF "smear" pat # pI "^smear" busid
smearrecv :: Pattern p => p Int -> p ValueMap
smearrecv busid = pI "^smear" busid

-- |
songPtr :: Pattern p => p Double -> p ValueMap
songPtr = pF "songPtr"
songPtrTake :: Pattern p => String -> [Double] -> p ValueMap
songPtrTake name xs = pStateListF "songPtr" name xs
songPtrCount :: Pattern p => String -> p ValueMap
songPtrCount name = pStateF "songPtr" name (maybe 0 (+1))
songPtrCountTo :: Pattern p => String -> p Double -> p ValueMap
songPtrCountTo name ipat = innerJoin $ (\i -> pStateF "songPtr" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

songPtrbus :: Pattern p => p Int -> p Double -> p ValueMap
songPtrbus _ _ = error "Control parameter 'songPtr' can't be sent to a bus."

-- | a pattern of numbers which changes the speed of sample playback, i.e. a cheap way of changing pitch. Negative values will play the sample backwards!
speed :: Pattern p => p Double -> p ValueMap
speed = pF "speed"
speedTake :: Pattern p => String -> [Double] -> p ValueMap
speedTake name xs = pStateListF "speed" name xs
speedCount :: Pattern p => String -> p ValueMap
speedCount name = pStateF "speed" name (maybe 0 (+1))
speedCountTo :: Pattern p => String -> p Double -> p ValueMap
speedCountTo name ipat = innerJoin $ (\i -> pStateF "speed" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

speedbus :: Pattern p => p Int -> p Double -> p ValueMap
speedbus _ _ = error "Control parameter 'speed' can't be sent to a bus."

-- |
squiz :: Pattern p => p Double -> p ValueMap
squiz = pF "squiz"
squizTake :: Pattern p => String -> [Double] -> p ValueMap
squizTake name xs = pStateListF "squiz" name xs
squizCount :: Pattern p => String -> p ValueMap
squizCount name = pStateF "squiz" name (maybe 0 (+1))
squizCountTo :: Pattern p => String -> p Double -> p ValueMap
squizCountTo name ipat = innerJoin $ (\i -> pStateF "squiz" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

squizbus :: Pattern p => p Int -> p Double -> p ValueMap
squizbus busid pat = pF "squiz" pat # pI "^squiz" busid
squizrecv :: Pattern p => p Int -> p ValueMap
squizrecv busid = pI "^squiz" busid

-- |
stepsPerOctave :: Pattern p => p Double -> p ValueMap
stepsPerOctave = pF "stepsPerOctave"
stepsPerOctaveTake :: Pattern p => String -> [Double] -> p ValueMap
stepsPerOctaveTake name xs = pStateListF "stepsPerOctave" name xs
stepsPerOctaveCount :: Pattern p => String -> p ValueMap
stepsPerOctaveCount name = pStateF "stepsPerOctave" name (maybe 0 (+1))
stepsPerOctaveCountTo :: Pattern p => String -> p Double -> p ValueMap
stepsPerOctaveCountTo name ipat = innerJoin $ (\i -> pStateF "stepsPerOctave" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

stepsPerOctavebus :: Pattern p => p Int -> p Double -> p ValueMap
stepsPerOctavebus busid pat = pF "stepsPerOctave" pat # pI "^stepsPerOctave" busid
stepsPerOctaverecv :: Pattern p => p Int -> p ValueMap
stepsPerOctaverecv busid = pI "^stepsPerOctave" busid

-- |
stutterdepth :: Pattern p => p Double -> p ValueMap
stutterdepth = pF "stutterdepth"
stutterdepthTake :: Pattern p => String -> [Double] -> p ValueMap
stutterdepthTake name xs = pStateListF "stutterdepth" name xs
stutterdepthCount :: Pattern p => String -> p ValueMap
stutterdepthCount name = pStateF "stutterdepth" name (maybe 0 (+1))
stutterdepthCountTo :: Pattern p => String -> p Double -> p ValueMap
stutterdepthCountTo name ipat = innerJoin $ (\i -> pStateF "stutterdepth" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

stutterdepthbus :: Pattern p => p Int -> p Double -> p ValueMap
stutterdepthbus busid pat = pF "stutterdepth" pat # pI "^stutterdepth" busid
stutterdepthrecv :: Pattern p => p Int -> p ValueMap
stutterdepthrecv busid = pI "^stutterdepth" busid

-- |
stuttertime :: Pattern p => p Double -> p ValueMap
stuttertime = pF "stuttertime"
stuttertimeTake :: Pattern p => String -> [Double] -> p ValueMap
stuttertimeTake name xs = pStateListF "stuttertime" name xs
stuttertimeCount :: Pattern p => String -> p ValueMap
stuttertimeCount name = pStateF "stuttertime" name (maybe 0 (+1))
stuttertimeCountTo :: Pattern p => String -> p Double -> p ValueMap
stuttertimeCountTo name ipat = innerJoin $ (\i -> pStateF "stuttertime" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

stuttertimebus :: Pattern p => p Int -> p Double -> p ValueMap
stuttertimebus busid pat = pF "stuttertime" pat # pI "^stuttertime" busid
stuttertimerecv :: Pattern p => p Int -> p ValueMap
stuttertimerecv busid = pI "^stuttertime" busid

-- |
sustain :: Pattern p => p Double -> p ValueMap
sustain = pF "sustain"
sustainTake :: Pattern p => String -> [Double] -> p ValueMap
sustainTake name xs = pStateListF "sustain" name xs
sustainCount :: Pattern p => String -> p ValueMap
sustainCount name = pStateF "sustain" name (maybe 0 (+1))
sustainCountTo :: Pattern p => String -> p Double -> p ValueMap
sustainCountTo name ipat = innerJoin $ (\i -> pStateF "sustain" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sustainbus :: Pattern p => p Int -> p Double -> p ValueMap
sustainbus _ _ = error "Control parameter 'sustain' can't be sent to a bus."

-- |
sustainpedal :: Pattern p => p Double -> p ValueMap
sustainpedal = pF "sustainpedal"
sustainpedalTake :: Pattern p => String -> [Double] -> p ValueMap
sustainpedalTake name xs = pStateListF "sustainpedal" name xs
sustainpedalCount :: Pattern p => String -> p ValueMap
sustainpedalCount name = pStateF "sustainpedal" name (maybe 0 (+1))
sustainpedalCountTo :: Pattern p => String -> p Double -> p ValueMap
sustainpedalCountTo name ipat = innerJoin $ (\i -> pStateF "sustainpedal" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

sustainpedalbus :: Pattern p => p Int -> p Double -> p ValueMap
sustainpedalbus busid pat = pF "sustainpedal" pat # pI "^sustainpedal" busid
sustainpedalrecv :: Pattern p => p Int -> p ValueMap
sustainpedalrecv busid = pI "^sustainpedal" busid

-- | time stretch amount
timescale :: Pattern p => p Double -> p ValueMap
timescale = pF "timescale"
timescaleTake :: Pattern p => String -> [Double] -> p ValueMap
timescaleTake name xs = pStateListF "timescale" name xs
timescaleCount :: Pattern p => String -> p ValueMap
timescaleCount name = pStateF "timescale" name (maybe 0 (+1))
timescaleCountTo :: Pattern p => String -> p Double -> p ValueMap
timescaleCountTo name ipat = innerJoin $ (\i -> pStateF "timescale" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

timescalebus :: Pattern p => p Int -> p Double -> p ValueMap
timescalebus _ _ = error "Control parameter 'timescale' can't be sent to a bus."

-- | time stretch window size
timescalewin :: Pattern p => p Double -> p ValueMap
timescalewin = pF "timescalewin"
timescalewinTake :: Pattern p => String -> [Double] -> p ValueMap
timescalewinTake name xs = pStateListF "timescalewin" name xs
timescalewinCount :: Pattern p => String -> p ValueMap
timescalewinCount name = pStateF "timescalewin" name (maybe 0 (+1))
timescalewinCountTo :: Pattern p => String -> p Double -> p ValueMap
timescalewinCountTo name ipat = innerJoin $ (\i -> pStateF "timescalewin" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

timescalewinbus :: Pattern p => p Int -> p Double -> p ValueMap
timescalewinbus _ _ = error "Control parameter 'timescalewin' can't be sent to a bus."

-- | for internal sound routing
to :: Pattern p => p Double -> p ValueMap
to = pF "to"
toTake :: Pattern p => String -> [Double] -> p ValueMap
toTake name xs = pStateListF "to" name xs
toCount :: Pattern p => String -> p ValueMap
toCount name = pStateF "to" name (maybe 0 (+1))
toCountTo :: Pattern p => String -> p Double -> p ValueMap
toCountTo name ipat = innerJoin $ (\i -> pStateF "to" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

tobus :: Pattern p => p Int -> p Double -> p ValueMap
tobus busid pat = pF "to" pat # pI "^to" busid
torecv :: Pattern p => p Int -> p ValueMap
torecv busid = pI "^to" busid

-- | for internal sound routing
toArg :: Pattern p => p String -> p ValueMap
toArg = pS "toArg"
toArgTake :: Pattern p => String -> [Double] -> p ValueMap
toArgTake name xs = pStateListF "toArg" name xs
toArgbus :: Pattern p => p Int -> p String -> p ValueMap
toArgbus busid pat = pS "toArg" pat # pI "^toArg" busid
toArgrecv :: Pattern p => p Int -> p ValueMap
toArgrecv busid = pI "^toArg" busid

-- |
tomdecay :: Pattern p => p Double -> p ValueMap
tomdecay = pF "tomdecay"
tomdecayTake :: Pattern p => String -> [Double] -> p ValueMap
tomdecayTake name xs = pStateListF "tomdecay" name xs
tomdecayCount :: Pattern p => String -> p ValueMap
tomdecayCount name = pStateF "tomdecay" name (maybe 0 (+1))
tomdecayCountTo :: Pattern p => String -> p Double -> p ValueMap
tomdecayCountTo name ipat = innerJoin $ (\i -> pStateF "tomdecay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

tomdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
tomdecaybus busid pat = pF "tomdecay" pat # pI "^tomdecay" busid
tomdecayrecv :: Pattern p => p Int -> p ValueMap
tomdecayrecv busid = pI "^tomdecay" busid

-- | Tremolo Audio DSP effect | params are 'tremolorate' and 'tremolodepth'
tremolodepth :: Pattern p => p Double -> p ValueMap
tremolodepth = pF "tremolodepth"
tremolodepthTake :: Pattern p => String -> [Double] -> p ValueMap
tremolodepthTake name xs = pStateListF "tremolodepth" name xs
tremolodepthCount :: Pattern p => String -> p ValueMap
tremolodepthCount name = pStateF "tremolodepth" name (maybe 0 (+1))
tremolodepthCountTo :: Pattern p => String -> p Double -> p ValueMap
tremolodepthCountTo name ipat = innerJoin $ (\i -> pStateF "tremolodepth" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

tremolodepthbus :: Pattern p => p Int -> p Double -> p ValueMap
tremolodepthbus busid pat = pF "tremolodepth" pat # pI "^tremolodepth" busid
tremolodepthrecv :: Pattern p => p Int -> p ValueMap
tremolodepthrecv busid = pI "^tremolodepth" busid

-- | Tremolo Audio DSP effect | params are 'tremolorate' and 'tremolodepth'
tremolorate :: Pattern p => p Double -> p ValueMap
tremolorate = pF "tremolorate"
tremolorateTake :: Pattern p => String -> [Double] -> p ValueMap
tremolorateTake name xs = pStateListF "tremolorate" name xs
tremolorateCount :: Pattern p => String -> p ValueMap
tremolorateCount name = pStateF "tremolorate" name (maybe 0 (+1))
tremolorateCountTo :: Pattern p => String -> p Double -> p ValueMap
tremolorateCountTo name ipat = innerJoin $ (\i -> pStateF "tremolorate" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

tremoloratebus :: Pattern p => p Int -> p Double -> p ValueMap
tremoloratebus busid pat = pF "tremolorate" pat # pI "^tremolorate" busid
tremoloraterecv :: Pattern p => p Int -> p ValueMap
tremoloraterecv busid = pI "^tremolorate" busid

-- | tube distortion
triode :: Pattern p => p Double -> p ValueMap
triode = pF "triode"
triodeTake :: Pattern p => String -> [Double] -> p ValueMap
triodeTake name xs = pStateListF "triode" name xs
triodeCount :: Pattern p => String -> p ValueMap
triodeCount name = pStateF "triode" name (maybe 0 (+1))
triodeCountTo :: Pattern p => String -> p Double -> p ValueMap
triodeCountTo name ipat = innerJoin $ (\i -> pStateF "triode" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

triodebus :: Pattern p => p Int -> p Double -> p ValueMap
triodebus busid pat = pF "triode" pat # pI "^triode" busid
trioderecv :: Pattern p => p Int -> p ValueMap
trioderecv busid = pI "^triode" busid

-- |
tsdelay :: Pattern p => p Double -> p ValueMap
tsdelay = pF "tsdelay"
tsdelayTake :: Pattern p => String -> [Double] -> p ValueMap
tsdelayTake name xs = pStateListF "tsdelay" name xs
tsdelayCount :: Pattern p => String -> p ValueMap
tsdelayCount name = pStateF "tsdelay" name (maybe 0 (+1))
tsdelayCountTo :: Pattern p => String -> p Double -> p ValueMap
tsdelayCountTo name ipat = innerJoin $ (\i -> pStateF "tsdelay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

tsdelaybus :: Pattern p => p Int -> p Double -> p ValueMap
tsdelaybus busid pat = pF "tsdelay" pat # pI "^tsdelay" busid
tsdelayrecv :: Pattern p => p Int -> p ValueMap
tsdelayrecv busid = pI "^tsdelay" busid

-- |
uid :: Pattern p => p Double -> p ValueMap
uid = pF "uid"
uidTake :: Pattern p => String -> [Double] -> p ValueMap
uidTake name xs = pStateListF "uid" name xs
uidCount :: Pattern p => String -> p ValueMap
uidCount name = pStateF "uid" name (maybe 0 (+1))
uidCountTo :: Pattern p => String -> p Double -> p ValueMap
uidCountTo name ipat = innerJoin $ (\i -> pStateF "uid" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

uidbus :: Pattern p => p Int -> p Double -> p ValueMap
uidbus _ _ = error "Control parameter 'uid' can't be sent to a bus."

-- | used in conjunction with `speed`, accepts values of "r" (rate, default behavior), "c" (cycles), or "s" (seconds). Using `unit "c"` means `speed` will be interpreted in units of cycles, e.g. `speed "1"` means samples will be stretched to fill a cycle. Using `unit "s"` means the playback speed will be adjusted so that the duration is the number of seconds specified by `speed`.
unit :: Pattern p => p String -> p ValueMap
unit = pS "unit"
unitTake :: Pattern p => String -> [Double] -> p ValueMap
unitTake name xs = pStateListF "unit" name xs
unitbus :: Pattern p => p Int -> p String -> p ValueMap
unitbus _ _ = error "Control parameter 'unit' can't be sent to a bus."

-- |
val :: Pattern p => p Double -> p ValueMap
val = pF "val"
valTake :: Pattern p => String -> [Double] -> p ValueMap
valTake name xs = pStateListF "val" name xs
valCount :: Pattern p => String -> p ValueMap
valCount name = pStateF "val" name (maybe 0 (+1))
valCountTo :: Pattern p => String -> p Double -> p ValueMap
valCountTo name ipat = innerJoin $ (\i -> pStateF "val" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

valbus :: Pattern p => p Int -> p Double -> p ValueMap
valbus _ _ = error "Control parameter 'val' can't be sent to a bus."

-- |
vcfegint :: Pattern p => p Double -> p ValueMap
vcfegint = pF "vcfegint"
vcfegintTake :: Pattern p => String -> [Double] -> p ValueMap
vcfegintTake name xs = pStateListF "vcfegint" name xs
vcfegintCount :: Pattern p => String -> p ValueMap
vcfegintCount name = pStateF "vcfegint" name (maybe 0 (+1))
vcfegintCountTo :: Pattern p => String -> p Double -> p ValueMap
vcfegintCountTo name ipat = innerJoin $ (\i -> pStateF "vcfegint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

vcfegintbus :: Pattern p => p Int -> p Double -> p ValueMap
vcfegintbus busid pat = pF "vcfegint" pat # pI "^vcfegint" busid
vcfegintrecv :: Pattern p => p Int -> p ValueMap
vcfegintrecv busid = pI "^vcfegint" busid

-- |
vcoegint :: Pattern p => p Double -> p ValueMap
vcoegint = pF "vcoegint"
vcoegintTake :: Pattern p => String -> [Double] -> p ValueMap
vcoegintTake name xs = pStateListF "vcoegint" name xs
vcoegintCount :: Pattern p => String -> p ValueMap
vcoegintCount name = pStateF "vcoegint" name (maybe 0 (+1))
vcoegintCountTo :: Pattern p => String -> p Double -> p ValueMap
vcoegintCountTo name ipat = innerJoin $ (\i -> pStateF "vcoegint" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

vcoegintbus :: Pattern p => p Int -> p Double -> p ValueMap
vcoegintbus busid pat = pF "vcoegint" pat # pI "^vcoegint" busid
vcoegintrecv :: Pattern p => p Int -> p ValueMap
vcoegintrecv busid = pI "^vcoegint" busid

-- |
velocity :: Pattern p => p Double -> p ValueMap
velocity = pF "velocity"
velocityTake :: Pattern p => String -> [Double] -> p ValueMap
velocityTake name xs = pStateListF "velocity" name xs
velocityCount :: Pattern p => String -> p ValueMap
velocityCount name = pStateF "velocity" name (maybe 0 (+1))
velocityCountTo :: Pattern p => String -> p Double -> p ValueMap
velocityCountTo name ipat = innerJoin $ (\i -> pStateF "velocity" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

velocitybus :: Pattern p => p Int -> p Double -> p ValueMap
velocitybus busid pat = pF "velocity" pat # pI "^velocity" busid
velocityrecv :: Pattern p => p Int -> p ValueMap
velocityrecv busid = pI "^velocity" busid

-- |
voice :: Pattern p => p Double -> p ValueMap
voice = pF "voice"
voiceTake :: Pattern p => String -> [Double] -> p ValueMap
voiceTake name xs = pStateListF "voice" name xs
voiceCount :: Pattern p => String -> p ValueMap
voiceCount name = pStateF "voice" name (maybe 0 (+1))
voiceCountTo :: Pattern p => String -> p Double -> p ValueMap
voiceCountTo name ipat = innerJoin $ (\i -> pStateF "voice" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

voicebus :: Pattern p => p Int -> p Double -> p ValueMap
voicebus busid pat = pF "voice" pat # pI "^voice" busid
voicerecv :: Pattern p => p Int -> p ValueMap
voicerecv busid = pI "^voice" busid

-- | formant filter to make things sound like vowels, a pattern of either `a`, `e`, `i`, `o` or `u`. Use a rest (`~`) for no effect.
vowel :: Pattern p => p String -> p ValueMap
vowel = pS "vowel"
vowelTake :: Pattern p => String -> [Double] -> p ValueMap
vowelTake name xs = pStateListF "vowel" name xs
vowelbus :: Pattern p => p Int -> p String -> p ValueMap
vowelbus busid pat = pS "vowel" pat # pI "^vowel" busid
vowelrecv :: Pattern p => p Int -> p ValueMap
vowelrecv busid = pI "^vowel" busid

-- |
waveloss :: Pattern p => p Double -> p ValueMap
waveloss = pF "waveloss"
wavelossTake :: Pattern p => String -> [Double] -> p ValueMap
wavelossTake name xs = pStateListF "waveloss" name xs
wavelossCount :: Pattern p => String -> p ValueMap
wavelossCount name = pStateF "waveloss" name (maybe 0 (+1))
wavelossCountTo :: Pattern p => String -> p Double -> p ValueMap
wavelossCountTo name ipat = innerJoin $ (\i -> pStateF "waveloss" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

wavelossbus :: Pattern p => p Int -> p Double -> p ValueMap
wavelossbus busid pat = pF "waveloss" pat # pI "^waveloss" busid
wavelossrecv :: Pattern p => p Int -> p ValueMap
wavelossrecv busid = pI "^waveloss" busid

-- |
xsdelay :: Pattern p => p Double -> p ValueMap
xsdelay = pF "xsdelay"
xsdelayTake :: Pattern p => String -> [Double] -> p ValueMap
xsdelayTake name xs = pStateListF "xsdelay" name xs
xsdelayCount :: Pattern p => String -> p ValueMap
xsdelayCount name = pStateF "xsdelay" name (maybe 0 (+1))
xsdelayCountTo :: Pattern p => String -> p Double -> p ValueMap
xsdelayCountTo name ipat = innerJoin $ (\i -> pStateF "xsdelay" name (maybe 0 ((`mod'` i) . (+1)))) <$> ipat

xsdelaybus :: Pattern p => p Int -> p Double -> p ValueMap
xsdelaybus busid pat = pF "xsdelay" pat # pI "^xsdelay" busid
xsdelayrecv :: Pattern p => p Int -> p ValueMap
xsdelayrecv busid = pI "^xsdelay" busid



-- aliases

voi :: Pattern p => p Double -> p ValueMap
voi = voice
voibus :: Pattern p => p Int -> p Double -> p ValueMap
voibus = voicebus
voirecv :: Pattern p => p Int -> p ValueMap
voirecv = voicerecv

vco :: Pattern p => p Double -> p ValueMap
vco = vcoegint
vcobus :: Pattern p => p Int -> p Double -> p ValueMap
vcobus = vcoegintbus
vcorecv :: Pattern p => p Int -> p ValueMap
vcorecv = vcoegintrecv

vcf :: Pattern p => p Double -> p ValueMap
vcf = vcfegint
vcfbus :: Pattern p => p Int -> p Double -> p ValueMap
vcfbus = vcfegintbus
vcfrecv :: Pattern p => p Int -> p ValueMap
vcfrecv = vcfegintrecv

up :: Pattern p => p Note -> p ValueMap
up = note

tremr :: Pattern p => p Double -> p ValueMap
tremr = tremolorate
tremrbus :: Pattern p => p Int -> p Double -> p ValueMap
tremrbus = tremoloratebus
tremrrecv :: Pattern p => p Int -> p ValueMap
tremrrecv = tremoloraterecv

tremdp :: Pattern p => p Double -> p ValueMap
tremdp = tremolodepth
tremdpbus :: Pattern p => p Int -> p Double -> p ValueMap
tremdpbus = tremolodepthbus
tremdprecv :: Pattern p => p Int -> p ValueMap
tremdprecv = tremolodepthrecv

tdecay :: Pattern p => p Double -> p ValueMap
tdecay = tomdecay
tdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
tdecaybus = tomdecaybus
tdecayrecv :: Pattern p => p Int -> p ValueMap
tdecayrecv = tomdecayrecv

sz :: Pattern p => p Double -> p ValueMap
sz = size
szbus :: Pattern p => p Int -> p Double -> p ValueMap
szbus = sizebus
szrecv :: Pattern p => p Int -> p ValueMap
szrecv = sizerecv

sus :: Pattern p => p Double -> p ValueMap
sus = sustain

stt :: Pattern p => p Double -> p ValueMap
stt = stuttertime
sttbus :: Pattern p => p Int -> p Double -> p ValueMap
sttbus = stuttertimebus
sttrecv :: Pattern p => p Int -> p ValueMap
sttrecv = stuttertimerecv

std :: Pattern p => p Double -> p ValueMap
std = stutterdepth
stdbus :: Pattern p => p Int -> p Double -> p ValueMap
stdbus = stutterdepthbus
stdrecv :: Pattern p => p Int -> p ValueMap
stdrecv = stutterdepthrecv

sld :: Pattern p => p Double -> p ValueMap
sld = slide
sldbus :: Pattern p => p Int -> p Double -> p ValueMap
sldbus = slidebus
sldrecv :: Pattern p => p Int -> p ValueMap
sldrecv = sliderecv

scr :: Pattern p => p Double -> p ValueMap
scr = scrash
scrbus :: Pattern p => p Int -> p Double -> p ValueMap
scrbus = scrashbus
scrrecv :: Pattern p => p Int -> p ValueMap
scrrecv = scrashrecv

scp :: Pattern p => p Double -> p ValueMap
scp = sclap
scpbus :: Pattern p => p Int -> p Double -> p ValueMap
scpbus = sclapbus
scprecv :: Pattern p => p Int -> p ValueMap
scprecv = sclaprecv

scl :: Pattern p => p Double -> p ValueMap
scl = sclaves
sclbus :: Pattern p => p Int -> p Double -> p ValueMap
sclbus = sclavesbus
sclrecv :: Pattern p => p Int -> p ValueMap
sclrecv = sclavesrecv

sag :: Pattern p => p Double -> p ValueMap
sag = sagogo
sagbus :: Pattern p => p Int -> p Double -> p ValueMap
sagbus = sagogobus
sagrecv :: Pattern p => p Int -> p ValueMap
sagrecv = sagogorecv

s :: Pattern p => p String -> p ValueMap
s = sound

rel :: Pattern p => p Double -> p ValueMap
rel = release
relbus :: Pattern p => p Int -> p Double -> p ValueMap
relbus = releasebus
relrecv :: Pattern p => p Int -> p ValueMap
relrecv = releaserecv

por :: Pattern p => p Double -> p ValueMap
por = portamento
porbus :: Pattern p => p Int -> p Double -> p ValueMap
porbus = portamentobus
porrecv :: Pattern p => p Int -> p ValueMap
porrecv = portamentorecv

pit3 :: Pattern p => p Double -> p ValueMap
pit3 = pitch3
pit3bus :: Pattern p => p Int -> p Double -> p ValueMap
pit3bus = pitch3bus
pit3recv :: Pattern p => p Int -> p ValueMap
pit3recv = pitch3recv

pit2 :: Pattern p => p Double -> p ValueMap
pit2 = pitch2
pit2bus :: Pattern p => p Int -> p Double -> p ValueMap
pit2bus = pitch2bus
pit2recv :: Pattern p => p Int -> p ValueMap
pit2recv = pitch2recv

pit1 :: Pattern p => p Double -> p ValueMap
pit1 = pitch1
pit1bus :: Pattern p => p Int -> p Double -> p ValueMap
pit1bus = pitch1bus
pit1recv :: Pattern p => p Int -> p ValueMap
pit1recv = pitch1recv

phasr :: Pattern p => p Double -> p ValueMap
phasr = phaserrate
phasrbus :: Pattern p => p Int -> p Double -> p ValueMap
phasrbus = phaserratebus
phasrrecv :: Pattern p => p Int -> p ValueMap
phasrrecv = phaserraterecv

phasdp :: Pattern p => p Double -> p ValueMap
phasdp = phaserdepth
phasdpbus :: Pattern p => p Int -> p Double -> p ValueMap
phasdpbus = phaserdepthbus
phasdprecv :: Pattern p => p Int -> p ValueMap
phasdprecv = phaserdepthrecv

ohdecay :: Pattern p => p Double -> p ValueMap
ohdecay = ophatdecay
ohdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
ohdecaybus = ophatdecaybus
ohdecayrecv :: Pattern p => p Int -> p ValueMap
ohdecayrecv = ophatdecayrecv

number :: Pattern p => p Note -> p ValueMap
number = n

lsn :: Pattern p => p Double -> p ValueMap
lsn = lsnare
lsnbus :: Pattern p => p Int -> p Double -> p ValueMap
lsnbus = lsnarebus
lsnrecv :: Pattern p => p Int -> p ValueMap
lsnrecv = lsnarerecv

lpq :: Pattern p => p Double -> p ValueMap
lpq = resonance
lpqbus :: Pattern p => p Int -> p Double -> p ValueMap
lpqbus = resonancebus
lpqrecv :: Pattern p => p Int -> p ValueMap
lpqrecv = resonancerecv

lpf :: Pattern p => p Double -> p ValueMap
lpf = cutoff
lpfbus :: Pattern p => p Int -> p Double -> p ValueMap
lpfbus = cutoffbus
lpfrecv :: Pattern p => p Int -> p ValueMap
lpfrecv = cutoffrecv

loh :: Pattern p => p Double -> p ValueMap
loh = lophat
lohbus :: Pattern p => p Int -> p Double -> p ValueMap
lohbus = lophatbus
lohrecv :: Pattern p => p Int -> p ValueMap
lohrecv = lophatrecv

llt :: Pattern p => p Double -> p ValueMap
llt = llotom
lltbus :: Pattern p => p Int -> p Double -> p ValueMap
lltbus = llotombus
lltrecv :: Pattern p => p Int -> p ValueMap
lltrecv = llotomrecv

lht :: Pattern p => p Double -> p ValueMap
lht = lhitom
lhtbus :: Pattern p => p Int -> p Double -> p ValueMap
lhtbus = lhitombus
lhtrecv :: Pattern p => p Int -> p ValueMap
lhtrecv = lhitomrecv

lfop :: Pattern p => p Double -> p ValueMap
lfop = lfopitchint
lfopbus :: Pattern p => p Int -> p Double -> p ValueMap
lfopbus = lfopitchintbus
lfoprecv :: Pattern p => p Int -> p ValueMap
lfoprecv = lfopitchintrecv

lfoi :: Pattern p => p Double -> p ValueMap
lfoi = lfoint
lfoibus :: Pattern p => p Int -> p Double -> p ValueMap
lfoibus = lfointbus
lfoirecv :: Pattern p => p Int -> p ValueMap
lfoirecv = lfointrecv

lfoc :: Pattern p => p Double -> p ValueMap
lfoc = lfocutoffint
lfocbus :: Pattern p => p Int -> p Double -> p ValueMap
lfocbus = lfocutoffintbus
lfocrecv :: Pattern p => p Int -> p ValueMap
lfocrecv = lfocutoffintrecv

lcr :: Pattern p => p Double -> p ValueMap
lcr = lcrash
lcrbus :: Pattern p => p Int -> p Double -> p ValueMap
lcrbus = lcrashbus
lcrrecv :: Pattern p => p Int -> p ValueMap
lcrrecv = lcrashrecv

lcp :: Pattern p => p Double -> p ValueMap
lcp = lclap
lcpbus :: Pattern p => p Int -> p Double -> p ValueMap
lcpbus = lclapbus
lcprecv :: Pattern p => p Int -> p ValueMap
lcprecv = lclaprecv

lcl :: Pattern p => p Double -> p ValueMap
lcl = lclaves
lclbus :: Pattern p => p Int -> p Double -> p ValueMap
lclbus = lclavesbus
lclrecv :: Pattern p => p Int -> p ValueMap
lclrecv = lclavesrecv

lch :: Pattern p => p Double -> p ValueMap
lch = lclhat
lchbus :: Pattern p => p Int -> p Double -> p ValueMap
lchbus = lclhatbus
lchrecv :: Pattern p => p Int -> p ValueMap
lchrecv = lclhatrecv

lbd :: Pattern p => p Double -> p ValueMap
lbd = lkick
lbdbus :: Pattern p => p Int -> p Double -> p ValueMap
lbdbus = lkickbus
lbdrecv :: Pattern p => p Int -> p ValueMap
lbdrecv = lkickrecv

lag :: Pattern p => p Double -> p ValueMap
lag = lagogo
lagbus :: Pattern p => p Int -> p Double -> p ValueMap
lagbus = lagogobus
lagrecv :: Pattern p => p Int -> p ValueMap
lagrecv = lagogorecv

hpq :: Pattern p => p Double -> p ValueMap
hpq = hresonance
hpqbus :: Pattern p => p Int -> p Double -> p ValueMap
hpqbus = hresonancebus
hpqrecv :: Pattern p => p Int -> p ValueMap
hpqrecv = hresonancerecv

hpf :: Pattern p => p Double -> p ValueMap
hpf = hcutoff
hpfbus :: Pattern p => p Int -> p Double -> p ValueMap
hpfbus = hcutoffbus
hpfrecv :: Pattern p => p Int -> p ValueMap
hpfrecv = hcutoffrecv

hg :: Pattern p => p Double -> p ValueMap
hg = hatgrain
hgbus :: Pattern p => p Int -> p Double -> p ValueMap
hgbus = hatgrainbus
hgrecv :: Pattern p => p Int -> p ValueMap
hgrecv = hatgrainrecv

gat :: Pattern p => p Double -> p ValueMap
gat = gate
gatbus :: Pattern p => p Int -> p Double -> p ValueMap
gatbus = gatebus
gatrecv :: Pattern p => p Int -> p ValueMap
gatrecv = gaterecv

fadeOutTime :: Pattern p => p Double -> p ValueMap
fadeOutTime = fadeTime

dt :: Pattern p => p Double -> p ValueMap
dt = delaytime
dtbus :: Pattern p => p Int -> p Double -> p ValueMap
dtbus = delaytimebus
dtrecv :: Pattern p => p Int -> p ValueMap
dtrecv = delaytimerecv

dfb :: Pattern p => p Double -> p ValueMap
dfb = delayfeedback
dfbbus :: Pattern p => p Int -> p Double -> p ValueMap
dfbbus = delayfeedbackbus
dfbrecv :: Pattern p => p Int -> p ValueMap
dfbrecv = delayfeedbackrecv

det :: Pattern p => p Double -> p ValueMap
det = detune
detbus :: Pattern p => p Int -> p Double -> p ValueMap
detbus = detunebus
detrecv :: Pattern p => p Int -> p ValueMap
detrecv = detunerecv

delayt :: Pattern p => p Double -> p ValueMap
delayt = delaytime
delaytbus :: Pattern p => p Int -> p Double -> p ValueMap
delaytbus = delaytimebus
delaytrecv :: Pattern p => p Int -> p ValueMap
delaytrecv = delaytimerecv

delayfb :: Pattern p => p Double -> p ValueMap
delayfb = delayfeedback
delayfbbus :: Pattern p => p Int -> p Double -> p ValueMap
delayfbbus = delayfeedbackbus
delayfbrecv :: Pattern p => p Int -> p ValueMap
delayfbrecv = delayfeedbackrecv

ctfg :: Pattern p => p Double -> p ValueMap
ctfg = cutoffegint
ctfgbus :: Pattern p => p Int -> p Double -> p ValueMap
ctfgbus = cutoffegintbus
ctfgrecv :: Pattern p => p Int -> p ValueMap
ctfgrecv = cutoffegintrecv

ctf :: Pattern p => p Double -> p ValueMap
ctf = cutoff
ctfbus :: Pattern p => p Int -> p Double -> p ValueMap
ctfbus = cutoffbus
ctfrecv :: Pattern p => p Int -> p ValueMap
ctfrecv = cutoffrecv

chdecay :: Pattern p => p Double -> p ValueMap
chdecay = clhatdecay
chdecaybus :: Pattern p => p Int -> p Double -> p ValueMap
chdecaybus = clhatdecaybus
chdecayrecv :: Pattern p => p Int -> p ValueMap
chdecayrecv = clhatdecayrecv

bpq :: Pattern p => p Double -> p ValueMap
bpq = bandq
bpqbus :: Pattern p => p Int -> p Double -> p ValueMap
bpqbus = bandqbus
bpqrecv :: Pattern p => p Int -> p ValueMap
bpqrecv = bandqrecv

bpf :: Pattern p => p Double -> p ValueMap
bpf = bandf
bpfbus :: Pattern p => p Int -> p Double -> p ValueMap
bpfbus = bandfbus
bpfrecv :: Pattern p => p Int -> p ValueMap
bpfrecv = bandfrecv

att :: Pattern p => p Double -> p ValueMap
att = attack
attbus :: Pattern p => p Int -> p Double -> p ValueMap
attbus = attackbus
attrecv :: Pattern p => p Int -> p ValueMap
attrecv = attackrecv
